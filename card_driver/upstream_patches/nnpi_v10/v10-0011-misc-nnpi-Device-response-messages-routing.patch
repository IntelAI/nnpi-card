From 6a9e2cce54b780f7b626a921fe46ace81baf43fa Mon Sep 17 00:00:00 2001
From: Guy Zadicario <guy.zadicario@intel.com>
Date: Mon, 5 Oct 2020 13:17:51 +0300
Subject: [PATCH v10 11/22] misc: nnpi: Device response messages routing

Route both types of messages coming from the NNP-I device - event report
messages, which are handled by the driver, and command-response messages,
which should be routed to a specific command channel object ("channel").

Event report messages are device-level messages which are not associated
with a specific channel. They are typically initiated by the NNP-I device,
to indicate an error, status change, or any event which is not a response
to a message sent from a spcific channel. These event report messages are
handled by the driver.

In contrast, command-response messages are associated with a specific
channel, and are typically sent from the NNP-i device in response to a
message sent from a channel to the device. These command-response messages
are added to the intended channel ring-buffer for consumption by this
channel.

The list of messages, of both types, coming from the device, is defined
in ipc_include/ipc_c2h_events.h included in this patch.

Signed-off-by: Guy Zadicario <guy.zadicario@intel.com>
Reviewed-by: Vaibhav Agarwal <vaibhav.agarwal@intel.com>
---
 drivers/misc/intel-nnpi/cmd_chan.h                 |   4 +
 drivers/misc/intel-nnpi/device.c                   | 111 +++++++++++
 drivers/misc/intel-nnpi/device.h                   |  36 ++++
 .../misc/intel-nnpi/ipc_include/ipc_c2h_events.h   | 204 +++++++++++++++++++++
 drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h |   1 +
 5 files changed, 356 insertions(+)
 create mode 100644 drivers/misc/intel-nnpi/ipc_include/ipc_c2h_events.h

diff --git a/drivers/misc/intel-nnpi/cmd_chan.h b/drivers/misc/intel-nnpi/cmd_chan.h
index 8de2ec0..73ccfb1 100644
--- a/drivers/misc/intel-nnpi/cmd_chan.h
+++ b/drivers/misc/intel-nnpi/cmd_chan.h
@@ -26,6 +26,7 @@
  * @chan_id: the ipc channel id for this channel
  * @hash_node: node to include this object in list of channels
  *             hash is in (cmd_chan_hash in nnp_device).
+ * @card_critical_error: last critical event report received from device
  * @get_device_events: true if device-level events received from device should
  *                     be sent over this channel to user.
  * @cmdq: message queue added to msg_scheduler, for user commands to be sent
@@ -45,6 +46,7 @@ struct nnp_chan {
 	struct nnp_device      *nnpdev;
 	u16                    chan_id;
 	struct hlist_node      hash_node;
+	union c2h_event_report card_critical_error;
 	bool                   get_device_events;
 
 	struct nnp_msched_queue     *cmdq;
@@ -58,6 +60,8 @@ struct nnp_chan {
 	char             *respq_buf;
 };
 
+#define chan_broken(chan) ((chan)->card_critical_error.event_code)
+
 int nnpdev_chan_create(struct nnp_device *nnpdev, int host_fd, u32 weight,
 		       unsigned int min_id, unsigned int max_id,
 		       bool get_device_events, struct nnp_chan **out_cmd_chan);
diff --git a/drivers/misc/intel-nnpi/device.c b/drivers/misc/intel-nnpi/device.c
index 31435881..1f3c9da 100644
--- a/drivers/misc/intel-nnpi/device.c
+++ b/drivers/misc/intel-nnpi/device.c
@@ -21,6 +21,7 @@
 #include "bootimage.h"
 #include "cmd_chan.h"
 #include "host_chardev.h"
+#include "ipc_c2h_events.h"
 #include "nnp_boot_defs.h"
 
 static unsigned int num_devices;
@@ -229,6 +230,114 @@ struct nnp_chan *nnpdev_find_channel(struct nnp_device *nnpdev, u16 chan_id)
 	return NULL;
 }
 
+void nnpdev_submit_device_event_to_channels(struct nnp_device *nnpdev,
+					    union c2h_event_report *event_msg,
+					    bool force)
+{
+	struct nnp_chan *cmd_chan;
+	int i;
+
+	spin_lock(&nnpdev->lock);
+	hash_for_each(nnpdev->cmd_chan_hash, i, cmd_chan, hash_node) {
+		if (is_card_fatal_event(event_msg->event_code) &&
+		    !is_card_fatal_drv_event(chan_broken(cmd_chan))) {
+			cmd_chan->card_critical_error.value = event_msg->value;
+			wake_up_all(&nnpdev->waitq);
+		}
+
+		if (force || cmd_chan->get_device_events)
+			nnp_chan_add_response(cmd_chan, (u64 *)event_msg,
+					      sizeof(*event_msg));
+	}
+	spin_unlock(&nnpdev->lock);
+}
+
+/*
+ * this function handle device-level event report message.
+ * which is usually affect the entire device and not a single channel
+ */
+static void process_device_event(struct nnp_device *nnpdev,
+				 union c2h_event_report *event_msg)
+{
+	bool force = is_card_fatal_event(event_msg->event_code);
+
+	nnpdev_submit_device_event_to_channels(nnpdev, event_msg, force);
+}
+
+struct event_report_work {
+	struct work_struct work;
+	struct nnp_device    *nnpdev;
+	union c2h_event_report msg;
+};
+
+static void device_event_report_handler(struct work_struct *work)
+{
+	struct event_report_work *req =
+		container_of(work, struct event_report_work, work);
+
+	process_device_event(req->nnpdev, &req->msg);
+
+	kfree(req);
+}
+
+static int handle_event_report(struct nnp_device *nnpdev, const u64 *msgbuf,
+			       int avail_qwords)
+{
+	int msg_qwords = 1; /* EVENT_REPORT response len is 1 qword */
+	union c2h_event_report ev;
+	struct event_report_work *req;
+
+	if (avail_qwords < msg_qwords)
+		return 0;
+
+	/* unpack the event report fields from the response message */
+	ev.value = 0;
+	ev.opcode = NNP_IPC_C2H_OP_EVENT_REPORT;
+	ev.event_code = FIELD_GET(NNP_C2H_EVENT_REPORT_CODE_MASK, msgbuf[0]);
+	ev.event_val = FIELD_GET(NNP_C2H_EVENT_REPORT_VAL_MASK, msgbuf[0]);
+	ev.chan_valid = FIELD_GET(NNP_C2H_EVENT_REPORT_CHAN_VALID_MASK,
+				  msgbuf[0]);
+	ev.obj_valid = FIELD_GET(NNP_C2H_EVENT_REPORT_OBJ_VALID_MASK,
+				 msgbuf[0]);
+	ev.obj_valid_2 = FIELD_GET(NNP_C2H_EVENT_REPORT_OBJ2_VALID_MASK,
+				   msgbuf[0]);
+	if (ev.chan_valid)
+		ev.chan_id = FIELD_GET(NNP_C2H_EVENT_REPORT_CHAN_ID_MASK,
+				       msgbuf[0]);
+	if (ev.obj_valid)
+		ev.obj_id = FIELD_GET(NNP_C2H_EVENT_REPORT_OBJ_ID_MASK,
+				      msgbuf[0]);
+	if (ev.obj_valid_2)
+		ev.obj_id_2 = FIELD_GET(NNP_C2H_EVENT_REPORT_OBJ_ID2_MASK,
+					msgbuf[0]);
+
+	if (ev.chan_valid) {
+		struct nnp_chan *cmd_chan;
+
+		cmd_chan = nnpdev_find_channel(nnpdev, ev.chan_id);
+		if (cmd_chan) {
+			nnp_chan_add_response(cmd_chan, (u64 *)&ev, sizeof(ev));
+			nnp_chan_put(cmd_chan);
+		} else {
+			dev_dbg(nnpdev->hw_dev->dev,
+				"Got Event Report for non existing channel id %d\n",
+				ev.chan_id);
+		}
+		return msg_qwords;
+	}
+
+	req = kzalloc(sizeof(*req), GFP_NOWAIT);
+	if (!req)
+		return msg_qwords;
+
+	req->msg.value = ev.value;
+	req->nnpdev = nnpdev;
+	INIT_WORK(&req->work, device_event_report_handler);
+	queue_work(nnpdev->wq, &req->work);
+
+	return msg_qwords;
+}
+
 static int handle_sys_info(struct nnp_device *nnpdev, const u64 *msgbuf,
 			   int avail_qwords)
 {
@@ -256,6 +365,7 @@ typedef int (*response_handler)(struct nnp_device *nnpdev, const u64 *msgbuf,
 
 static response_handler resp_handlers[NNP_IPC_C2H_OPCODE_LAST + 1] = {
 	[NNP_IPC_C2H_OP_QUERY_VERSION_REPLY3] = handle_query_version_reply3,
+	[NNP_IPC_C2H_OP_EVENT_REPORT] = handle_event_report,
 	[NNP_IPC_C2H_OP_SYS_INFO] = handle_sys_info,
 	[NNP_IPC_C2H_OP_BIOS_PROTOCOL] = handle_bios_protocol
 };
@@ -668,6 +778,7 @@ struct nnp_device *nnpdev_create(struct nnp_hw_dev *hw_dev)
 
 	ida_init(&nnpdev->cmd_chan_ida);
 	hash_init(nnpdev->cmd_chan_hash);
+	init_waitqueue_head(&nnpdev->waitq);
 
 	ret = first_device_init();
 	if (ret)
diff --git a/drivers/misc/intel-nnpi/device.h b/drivers/misc/intel-nnpi/device.h
index 4ef0c1f..61cd3f5 100644
--- a/drivers/misc/intel-nnpi/device.h
+++ b/drivers/misc/intel-nnpi/device.h
@@ -75,6 +75,37 @@ struct query_version_work {
 };
 
 /**
+ * union c2h_event_report - packs device event report response in 64-bit object
+ * @event_code: device event code, indicate which event has happened
+ * @chan_id: valid only when @chan_valid is set. Holds channel id.
+ * @obj_id: valid only when @obj_valid is set, value meaning depends on
+ *          @event_code
+ * @obj_id_2: valid only when @obj_valid_2 is set, value meaning depends on
+ *            @event_code
+ * @event_val: event value, meaning depends on @event_code
+ * @value: single 64-bit object used to copy and check all fields,
+ *         zero value means the event is not initialized, a valid event value
+ *         will always be non-zero.
+ */
+union c2h_event_report {
+	struct {
+		unsigned int opcode      :  6;
+		unsigned int event_code  :  7;
+		unsigned int chan_id     :  8;
+		unsigned int obj_id      : 16;
+		unsigned int obj_id_2    : 16;
+		unsigned int event_val   :  8;
+		unsigned int chan_valid  :  1;
+		unsigned int obj_valid   :  1;
+		unsigned int obj_valid_2 :  1;
+	} __packed;
+	u64 value;
+} __packed;
+
+static_assert(sizeof(union c2h_event_report) == sizeof(u64),
+	      "sizeof union c2h_event_report must be 64-bits!!");
+
+/**
  * struct nnp_device - structure for NNP-I "logical" device info
  * @ref: refcount this object
  * @hw_dev: pointer to the "hw" device structure
@@ -99,6 +130,7 @@ struct query_version_work {
  * @response_num_msgs: number of qwords available in @response_buf
  * @cmd_chan_ida: allocate channel ids to be used in ipc protocol.
  * @cmd_chan_hash: maps command channel id to its struct pointer.
+ * @waitq: used to wait for device response messages
  * @bios_system_info_dma_addr: dma page allocated for bios system info.
  * @bios_system_info: virtual pointer to bios system info page
  * @bios_version_str: the device's started bios version string
@@ -149,6 +181,7 @@ struct nnp_device {
 
 	struct ida cmd_chan_ida;
 	DECLARE_HASHTABLE(cmd_chan_hash, 6);
+	wait_queue_head_t waitq;
 
 	dma_addr_t                  bios_system_info_dma_addr;
 	struct nnp_c2h_system_info  *bios_system_info;
@@ -185,5 +218,8 @@ struct nnp_device {
 void nnpdev_set_boot_state(struct nnp_device *nnpdev, u32 mask);
 
 struct nnp_chan *nnpdev_find_channel(struct nnp_device *nnpdev, u16 chan_id);
+void nnpdev_submit_device_event_to_channels(struct nnp_device *nnpdev,
+					    union c2h_event_report *event_msg,
+					    bool force);
 
 #endif
diff --git a/drivers/misc/intel-nnpi/ipc_include/ipc_c2h_events.h b/drivers/misc/intel-nnpi/ipc_include/ipc_c2h_events.h
new file mode 100644
index 0000000..10d6581
--- /dev/null
+++ b/drivers/misc/intel-nnpi/ipc_include/ipc_c2h_events.h
@@ -0,0 +1,204 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+#ifndef _NNP_IPC_C2H_EVENTS_H
+#define _NNP_IPC_C2H_EVENTS_H
+
+/**
+ * The following describes the possible values for a c2h_event_report message
+ * sent from card to host to report on some error or other events.
+ *
+ * The c2h_event_report message has the following fields available to describe
+ * the event:
+ *    event_code  - 8 bits value describing the type of event
+ *    event_val   - 8 bits value - interpetation depends on event_code
+ *    chan_id     - the protocol id of the channel in which the event was
+ *                 occurred.
+ *    obj_id      - 16 bits, interpretation depends on event_code, usually used
+ *                 to hold an inference object protocol ID.
+ *    obj_id_2    - 16 bits, in case obj_id is not enough to describe the object
+ * In this file we define the possible values for the above fields and document
+ * each field meaning for each possible event_code.
+ */
+
+/**
+ * Event codes ranges
+ *
+ * Those ranges should match the definition of RuntimeEventCodes
+ * defined in include/sphcsInference.h and used by the daemon/runtime
+ * interface !!!
+ *
+ * error codes are grouped into the following ranges:
+ *     0 -   3   ==> non error events generated by daemon/runtime
+ *     4 -  47   ==> non error events generated by card kernel driver
+ *    48 -  51   ==> non-critical error events generated by daemon/runtime
+ *    52 -  95   ==> non-critical error events generatd by kernel driver
+ *    96 - 103   ==> context-critical error events generated by daemon/runtime
+ *   104 - 111   ==> context-critical error events generated by kernel driver
+ *   112 - 119   ==> card-critical error events generated by daemon/runtime
+ *   120 - 127   ==> card-critical error events generated by kernel driver
+ *
+ * context-critical error event is one that puts the infer context in an
+ * un-recovarable error state.
+ * card-critical error event is one that make the card not useful for inference
+ * request until it is reset.
+ */
+#define EVENT_NON_ERR_START             0
+#define EVENT_NON_ERR_DRV_START         4
+#define EVENT_ERR_START                48
+#define EVENT_ERR_DRV_START            52
+#define EVENT_CONTEXT_FATAL_START      96
+#define EVENT_CONTEXT_FATAL_DRV_START 104
+#define EVENT_CARD_FATAL_START        112
+#define EVENT_CARD_FATAL_DRV_START    120
+
+#define is_context_fatal_event(e)  ({ \
+	int e_ = (e); \
+	(e_ >= EVENT_CONTEXT_FATAL_START && e_ < EVENT_CARD_FATAL_START); \
+})
+
+#define is_card_fatal_event(e)     ((e) >= EVENT_CARD_FATAL_START)
+#define is_card_fatal_drv_event(e)     ((e) >= EVENT_CARD_FATAL_DRV_START)
+
+#define NNP_IPC_RUNTIME_DONE   (EVENT_NON_ERR_START + 1)
+/*            MAX offset for EVENT_NON_ERR_START is 3 */
+
+/* non-error event codes */
+#define NNP_IPC_CREATE_CONTEXT_SUCCESS   (EVENT_NON_ERR_DRV_START + 0)
+#define NNP_IPC_CREATE_DEVRES_SUCCESS    (EVENT_NON_ERR_DRV_START + 1)
+#define NNP_IPC_CREATE_COPY_SUCCESS      (EVENT_NON_ERR_DRV_START + 2)
+#define NNP_IPC_EXECUTE_COPY_SUCCESS     (EVENT_NON_ERR_DRV_START + 3)
+#define NNP_IPC_DEVRES_DESTROYED         (EVENT_NON_ERR_DRV_START + 4)
+#define NNP_IPC_COPY_DESTROYED           (EVENT_NON_ERR_DRV_START + 5)
+#define NNP_IPC_CONTEXT_DESTROYED        (EVENT_NON_ERR_DRV_START + 6)
+#define NNP_IPC_CREATE_DEVNET_SUCCESS    (EVENT_NON_ERR_DRV_START + 7)
+#define NNP_IPC_DEVNET_DESTROYED         (EVENT_NON_ERR_DRV_START + 8)
+#define NNP_IPC_CREATE_INFREQ_SUCCESS    (EVENT_NON_ERR_DRV_START + 9)
+#define NNP_IPC_INFREQ_DESTROYED         (EVENT_NON_ERR_DRV_START + 10)
+#define NNP_IPC_RECOVER_CONTEXT_SUCCESS  (EVENT_NON_ERR_DRV_START + 11)
+#define NNP_IPC_THERMAL_TRIP_EVENT       (EVENT_NON_ERR_DRV_START + 12)
+#define NNP_IPC_DEVNET_ADD_RES_SUCCESS   (EVENT_NON_ERR_DRV_START + 13)
+#define NNP_IPC_DEVICE_STATE_CHANGED     (EVENT_NON_ERR_DRV_START + 14)
+#define NNP_IPC_DEVNET_RESOURCES_RESERVATION_SUCCESS \
+	(EVENT_NON_ERR_DRV_START + 15)
+#define NNP_IPC_DEVNET_RESOURCES_RELEASE_SUCCESS  (EVENT_NON_ERR_DRV_START + 16)
+#define NNP_IPC_CREATE_CHANNEL_SUCCESS   (EVENT_NON_ERR_DRV_START + 17)
+#define NNP_IPC_CHANNEL_DESTROYED        (EVENT_NON_ERR_DRV_START + 18)
+#define NNP_IPC_CHANNEL_SET_RB_SUCCESS   (EVENT_NON_ERR_DRV_START + 19)
+#define NNP_IPC_CHANNEL_MAP_HOSTRES_SUCCESS   (EVENT_NON_ERR_DRV_START + 20)
+#define NNP_IPC_CHANNEL_UNMAP_HOSTRES_SUCCESS (EVENT_NON_ERR_DRV_START + 21)
+#define NNP_IPC_ABORT_REQUEST            (EVENT_NON_ERR_DRV_START + 22)
+#define NNP_IPC_GET_FIFO                 (EVENT_NON_ERR_DRV_START + 23)
+#define NNP_IPC_CREATE_CMD_SUCCESS       (EVENT_NON_ERR_DRV_START + 24)
+#define NNP_IPC_CMD_DESTROYED            (EVENT_NON_ERR_DRV_START + 25)
+#define NNP_IPC_EXECUTE_CMD_COMPLETE     (EVENT_NON_ERR_DRV_START + 26)
+#define NNP_IPC_DEVNET_SET_PROPERTY_SUCCESS  (EVENT_NON_ERR_DRV_START + 27)
+#define NNP_IPC_EXECUTE_CPYLST_SUCCESS   (EVENT_NON_ERR_DRV_START + 28)
+#define NNP_IPC_GET_CR_FIFO_REPLY        (EVENT_NON_ERR_DRV_START + 29)
+#define NNP_IPC_P2P_PEERS_CONNECTED      (EVENT_NON_ERR_DRV_START + 30)
+#define NNP_IPC_P2P_PEER_DEV_UPDATED     (EVENT_NON_ERR_DRV_START + 31)
+#define NNP_IPC_EXECUTE_COPY_SUBRES_SUCCESS  (EVENT_NON_ERR_DRV_START + 32)
+/*                   MAX offset for EVENT_NON_ERR_DRV_START is 43 */
+
+/* non-critical error event codes */
+#define NNP_IPC_CREATE_CONTEXT_FAILED    (EVENT_ERR_DRV_START + 0)
+#define NNP_IPC_CREATE_DEVRES_FAILED     (EVENT_ERR_DRV_START + 1)
+#define NNP_IPC_CREATE_COPY_FAILED       (EVENT_ERR_DRV_START + 2)
+#define NNP_IPC_DESTROY_CONTEXT_FAILED   (EVENT_ERR_DRV_START + 3)
+#define NNP_IPC_DESTROY_DEVRES_FAILED    (EVENT_ERR_DRV_START + 4)
+#define NNP_IPC_DESTROY_COPY_FAILED      (EVENT_ERR_DRV_START + 5)
+#define NNP_IPC_CREATE_SYNC_FAILED       (EVENT_ERR_DRV_START + 6)
+#define NNP_IPC_ERROR_SUB_RESOURCE_LOAD_FAILED      (EVENT_ERR_DRV_START + 7)
+#define NNP_IPC_CREATE_DEVNET_FAILED     (EVENT_ERR_DRV_START + 8)
+#define NNP_IPC_DESTROY_DEVNET_FAILED    (EVENT_ERR_DRV_START + 9)
+#define NNP_IPC_CREATE_INFREQ_FAILED     (EVENT_ERR_DRV_START + 10)
+#define NNP_IPC_DESTROY_INFREQ_FAILED    (EVENT_ERR_DRV_START + 11)
+#define NNP_IPC_RECOVER_CONTEXT_FAILED   (EVENT_ERR_DRV_START + 12)
+#define NNP_IPC_ERROR_MCE_CORRECTABLE    (EVENT_ERR_DRV_START + 13)
+#define NNP_IPC_ERROR_MCE_UNCORRECTABLE  (EVENT_ERR_DRV_START + 14)
+#define NNP_IPC_DEVNET_ADD_RES_FAILED    (EVENT_ERR_DRV_START + 15)
+#define NNP_IPC_DEVNET_RESOURCES_RESERVATION_FAILED (EVENT_ERR_DRV_START + 16)
+#define NNP_IPC_DEVNET_RESOURCES_RELEASE_FAILED     (EVENT_ERR_DRV_START + 17)
+#define NNP_IPC_CREATE_CHANNEL_FAILED    (EVENT_ERR_DRV_START + 18)
+#define NNP_IPC_DESTROY_CHANNEL_FAILED   (EVENT_ERR_DRV_START + 19)
+#define NNP_IPC_CHANNEL_SET_RB_FAILED    (EVENT_ERR_DRV_START + 20)
+#define NNP_IPC_CREATE_CMD_FAILED        (EVENT_ERR_DRV_START + 21)
+#define NNP_IPC_DESTROY_CMD_FAILED       (EVENT_ERR_DRV_START + 22)
+#define NNP_IPC_CHANNEL_MAP_HOSTRES_FAILED   (EVENT_ERR_DRV_START + 23)
+#define NNP_IPC_CHANNEL_UNMAP_HOSTRES_FAILED (EVENT_ERR_DRV_START + 24)
+#define NNP_IPC_DEVNET_SET_PROPERTY_FAILED  (EVENT_ERR_DRV_START + 25)
+#define NNP_IPC_ERROR_DRAM_ECC_CORRECTABLE (EVENT_ERR_DRV_START + 26)
+#define NNP_IPC_EXECUTE_COPY_FAILED        (EVENT_ERR_DRV_START + 27)
+#define NNP_IPC_SCHEDULE_INFREQ_FAILED     (EVENT_ERR_DRV_START + 28)
+#define NNP_IPC_EXECUTE_CPYLST_FAILED      (EVENT_ERR_DRV_START + 29)
+#define NNP_IPC_EXECUTE_COPY_SUBRES_FAILED  (EVENT_ERR_DRV_START + 30)
+#define NNP_IPC_EC_FAILED_TO_RELEASE_CREDIT  (EVENT_ERR_DRV_START + 31)
+#define NNP_IPC_DMA_HANG_DETECTED            (EVENT_ERR_DRV_START + 32)
+/*                   MAX offset for EVENT_ERR_DRV_START is 43 */
+
+/* context critical error event codes */
+#define NNP_IPC_ERROR_RUNTIME_LAUNCH     (EVENT_CONTEXT_FATAL_START + 0)
+#define NNP_IPC_ERROR_RUNTIME_DIED       (EVENT_CONTEXT_FATAL_START + 1)
+/*                   MAX offset for EVENT_CONTEXT_FATAL_START is 7 */
+
+#define NNP_IPC_CONTEXT_EXEC_ERROR          (EVENT_CONTEXT_FATAL_DRV_START + 0)
+#define NNP_IPC_CTX_DRAM_ECC_UNCORRECTABLE  (EVENT_CONTEXT_FATAL_DRV_START + 1)
+/*                   MAX offset for EVENT_CONTEXT_FATAL_DRV_START is 7 */
+
+/* card critical error event codes */
+#define NNP_IPC_ERROR_OS_CRASHED          (EVENT_CARD_FATAL_START + 0)
+#define NNP_IPC_ERROR_DRAM_ECC_UNCORRECTABLE_FATAL  (EVENT_CARD_FATAL_START + 1)
+#define NNP_IPC_ERROR_FATAL_ICE_ERROR     (EVENT_CARD_FATAL_START + 2)
+/*                   MAX offset for EVENT_CARD_FATAL_START is 7 */
+
+/* card critical and driver fatal*/
+#define NNP_IPC_ERROR_PCI_ERROR           (EVENT_CARD_FATAL_DRV_START + 0)
+#define NNP_IPC_ERROR_MCE_UNCORRECTABLE_FATAL  (EVENT_CARD_FATAL_DRV_START + 1)
+#define NNP_IPC_ERROR_CARD_RESET          (EVENT_CARD_FATAL_DRV_START + 2)
+#define NNP_IPC_ERROR_CHANNEL_KILLED      (EVENT_CARD_FATAL_DRV_START + 3)
+#define NNP_IPC_ERROR_PROTOCOL_ERROR      (EVENT_CARD_FATAL_DRV_START + 4)
+#define NNP_IPC_FATAL_DMA_HANG_DETECTED   (EVENT_CARD_FATAL_DRV_START + 5)
+/*                   MAX offset for EVENT_CARD_FATAL_DRV_START is 7 */
+
+enum event_val {
+	NNP_IPC_NO_ERROR		= 0,
+	NNP_IPC_NO_SUCH_CONTEXT		= 1,
+	NNP_IPC_NO_SUCH_DEVRES		= 2,
+	NNP_IPC_NO_SUCH_COPY		= 3,
+	NNP_IPC_NO_SUCH_NET		= 4,
+	NNP_IPC_NO_SUCH_INFREQ		= 5,
+	NNP_IPC_ALREADY_EXIST		= 6,
+	NNP_IPC_NO_DAEMON		= 7,
+	NNP_IPC_NO_MEMORY		= 8,
+	NNP_IPC_RUNTIME_FAILED		= 9,
+	NNP_IPC_RUNTIME_LAUNCH_FAILED	= 10,
+	NNP_IPC_DMA_ERROR		= 11,
+	NNP_IPC_RUNTIME_NOT_SUPPORTED	= 12,
+	NNP_IPC_RUNTIME_INVALID_EXECUTABLE_NETWORK_BINARY = 13,
+	NNP_IPC_RUNTIME_INFER_MISSING_RESOURCE        = 14,
+	NNP_IPC_RUNTIME_INFER_EXEC_ERROR              = 15,
+	NNP_IPC_RUNTIME_INFER_SCHEDULE_ERROR          = 16,
+	NNP_IPC_CONTEXT_BROKEN                        = 17,
+	NNP_IPC_DEVNET_RESERVE_INSUFFICIENT_RESOURCES = 18,
+	NNP_IPC_TIMEOUT_EXCEEDED        = 19,
+	NNP_IPC_ECC_ALLOC_FAILED        = 20,
+	NNP_IPC_NO_SUCH_CHANNEL         = 21,
+	NNP_IPC_NO_SUCH_CMD             = 22,
+	NNP_IPC_NO_SUCH_HOSTRES         = 23,
+	NNP_IPC_DEVNET_EDIT_BUSY        = 24,
+	NNP_IPC_DEVNET_EDIT_ERROR       = 25,
+	NNP_IPC_NOT_SUPPORTED           = 26,
+	NNP_IPC_ICEDRV_INFER_EXEC_ERROR = 27,
+	NNP_IPC_ICEDRV_INFER_EXEC_ERROR_NEED_RESET = 28,
+	NNP_IPC_ICEDRV_INFER_EXEC_ERROR_NEED_CARD_RESET = 29,
+	NNP_IPC_NO_EXEC_ERRORS          = 30,
+	NNP_IPC_IO_ERROR                = 31,
+	NNP_IPC_INPUT_IS_DIRTY          = 32,
+
+	/* Non failure events */
+	NNP_IPC_CMDLIST_FINISHED       = 128,
+};
+
+#endif
diff --git a/drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h b/drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h
index 56a16eb..00201d7 100644
--- a/drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h
+++ b/drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h
@@ -8,6 +8,7 @@
 
 #include <linux/types.h>
 #include <linux/dma-mapping.h>
+#include "ipc_c2h_events.h"
 #include "nnp_inbound_mem.h"
 
 #define IPC_OP_MAX 64
-- 
1.8.3.1

