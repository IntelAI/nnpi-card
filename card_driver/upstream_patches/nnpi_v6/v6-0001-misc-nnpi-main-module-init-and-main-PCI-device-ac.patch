From 2f66689b3c4d217bc9148af66a7bad5a320411f4 Mon Sep 17 00:00:00 2001
From: Guy Zadicario <guy.zadicario@intel.com>
Date: Sat, 28 Mar 2020 17:58:39 +0300
Subject: [PATCH v6 01/19] misc: nnpi: main module init and main PCI device
 access functions

This patch includes the main module initialization, main PCI device
registration and access functions.

nnpdrv_main.c - The main module initialization and cleanup functions.
pcie.h - Defines interface between the functional "device" layer and
         the "pci" layer where all pci access functions are implemented.
pcie.c - The main pci registration and device access code.
device.c - Currently almost empty implementation of the functional "device" layer.
if_include/   - This directory will include h/w register definitions and protocol structures
                used to communicate with the NNPI device.

Signed-off-by: Guy Zadicario <guy.zadicario@intel.com>
Reviewed-by: Vaibhav Agarwal <vaibhav.agarwal@intel.com>
---
 MAINTAINERS                                        |   5 +
 drivers/misc/Kconfig                               |   1 +
 drivers/misc/Makefile                              |   1 +
 drivers/misc/intel-nnpi/Kconfig                    |  17 +
 drivers/misc/intel-nnpi/Makefile                   |  11 +
 drivers/misc/intel-nnpi/device.c                   | 178 +++++
 drivers/misc/intel-nnpi/device.h                   |  51 ++
 drivers/misc/intel-nnpi/if_include/nnp_boot_defs.h |  86 +++
 drivers/misc/intel-nnpi/if_include/nnp_debug.h     |  27 +
 drivers/misc/intel-nnpi/if_include/nnp_elbi.h      | 151 ++++
 .../misc/intel-nnpi/if_include/nnp_inbound_mem.h   |  38 +
 drivers/misc/intel-nnpi/nnp_log.h                  |  50 ++
 drivers/misc/intel-nnpi/nnp_time.h                 |  23 +
 drivers/misc/intel-nnpi/nnpdrv_main.c              |  61 ++
 drivers/misc/intel-nnpi/pcie.c                     | 855 +++++++++++++++++++++
 drivers/misc/intel-nnpi/pcie.h                     |  65 ++
 16 files changed, 1620 insertions(+)
 create mode 100644 drivers/misc/intel-nnpi/Kconfig
 create mode 100644 drivers/misc/intel-nnpi/Makefile
 create mode 100644 drivers/misc/intel-nnpi/device.c
 create mode 100644 drivers/misc/intel-nnpi/device.h
 create mode 100644 drivers/misc/intel-nnpi/if_include/nnp_boot_defs.h
 create mode 100644 drivers/misc/intel-nnpi/if_include/nnp_debug.h
 create mode 100644 drivers/misc/intel-nnpi/if_include/nnp_elbi.h
 create mode 100644 drivers/misc/intel-nnpi/if_include/nnp_inbound_mem.h
 create mode 100644 drivers/misc/intel-nnpi/nnp_log.h
 create mode 100644 drivers/misc/intel-nnpi/nnp_time.h
 create mode 100644 drivers/misc/intel-nnpi/nnpdrv_main.c
 create mode 100644 drivers/misc/intel-nnpi/pcie.c
 create mode 100644 drivers/misc/intel-nnpi/pcie.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 1d4aa7f..7b81640 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -8815,6 +8815,11 @@ F:	include/uapi/linux/mic_common.h
 F:	include/uapi/linux/mic_ioctl.h
 F:	include/uapi/linux/scif_ioctl.h
 
+INTEL NNP-I PCI DRIVER
+M:	Guy Zadicario <guy.zadicario@intel.com>
+S:	Supported
+F:	drivers/misc/intel-nnpi/
+
 INTEL P-Unit IPC DRIVER
 M:	Zha Qipeng <qipeng.zha@intel.com>
 L:	platform-driver-x86@vger.kernel.org
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index e1b1ba5..eef7f31 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -472,4 +472,5 @@ source "drivers/misc/ocxl/Kconfig"
 source "drivers/misc/cardreader/Kconfig"
 source "drivers/misc/habanalabs/Kconfig"
 source "drivers/misc/uacce/Kconfig"
+source "drivers/misc/intel-nnpi/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index c7bd01a..f8fd55d 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -57,3 +57,4 @@ obj-$(CONFIG_PVPANIC)   	+= pvpanic.o
 obj-$(CONFIG_HABANA_AI)		+= habanalabs/
 obj-$(CONFIG_UACCE)		+= uacce/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
+obj-$(CONFIG_INTEL_NNPI)        += intel-nnpi/
diff --git a/drivers/misc/intel-nnpi/Kconfig b/drivers/misc/intel-nnpi/Kconfig
new file mode 100644
index 0000000..a63dda5
--- /dev/null
+++ b/drivers/misc/intel-nnpi/Kconfig
@@ -0,0 +1,17 @@
+#
+# Copyright (C) 2019-2020 Intel Corporation
+#
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+
+config INTEL_NNPI
+	tristate "Intel(R) NNP-I (AI accelerator for inference) device driver"
+	depends on PCI
+	select DMA_SHARED_BUFFER
+	help
+	  Device driver for Intel NNP-I PCIe accelerator card for AI inference.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here. The module
+	  will be called intel_nnpidrv.
diff --git a/drivers/misc/intel-nnpi/Makefile b/drivers/misc/intel-nnpi/Makefile
new file mode 100644
index 0000000..efe96fa
--- /dev/null
+++ b/drivers/misc/intel-nnpi/Makefile
@@ -0,0 +1,11 @@
+#
+# Copyright (C) 2019-2020 Intel Corporation
+#
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+
+obj-m	:= intel_nnpidrv.o
+
+intel_nnpidrv-y := nnpdrv_main.o pcie.o device.o
+
+ccflags-y += -I$(srctree)/$(src)/if_include
diff --git a/drivers/misc/intel-nnpi/device.c b/drivers/misc/intel-nnpi/device.c
new file mode 100644
index 0000000..d091e59
--- /dev/null
+++ b/drivers/misc/intel-nnpi/device.c
@@ -0,0 +1,178 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#include "device.h"
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <linux/idr.h>
+#include <linux/jiffies.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/sched/clock.h>
+#include <linux/mutex.h>
+#include "nnp_log.h"
+#include "nnp_debug.h"
+#include "pcie.h"
+
+static struct ida s_dev_ida;
+
+int nnpdrv_device_init(void)
+{
+	ida_init(&s_dev_ida);
+	return 0;
+}
+
+void nnpdrv_device_fini(void)
+{
+	ida_destroy(&s_dev_ida);
+}
+
+/*
+ * HWQ messages handler,
+ * This function is *NOT* re-entrant!!!
+ * The pci layer call this function from bottom-half context,
+ * The function may not block !!!
+ */
+int nnpdrv_device_process_messages(struct nnp_device *nnpdev,
+				   u64               *hw_msg,
+				   u32                hw_nof_msg)
+{
+	/* placeholder - will be filled in later patches */
+	return hw_nof_msg;
+}
+
+int nnpdrv_device_create(void                              *hw_handle,
+			 const struct nnp_hw_device_info   *hw_device_info,
+			 const struct nnpdrv_device_hw_ops *hw_ops,
+			 struct nnp_device                **out_nnpdev)
+{
+	struct nnp_device *nnpdev;
+	int ret;
+
+	nnpdev = kzalloc(sizeof(*nnpdev), GFP_KERNEL);
+	if (!nnpdev)
+		return -ENOMEM;
+
+	nnpdev->id = -1;
+	ret = ida_simple_get(&s_dev_ida, 0, NNP_MAX_DEVS, GFP_KERNEL);
+	if (ret < 0) {
+		nnp_log_err(START_UP_LOG, "failed to allocate NNP-I device number\n");
+		goto err_exit;
+	}
+
+	nnpdev->id = ret;
+
+	nnp_log_debug(START_UP_LOG, "nnpdev id is : %u\n", nnpdev->id);
+
+	ret = snprintf(nnpdev->name,
+		       sizeof(nnpdev->name),
+		       "nnpdev%u", nnpdev->id);
+	if (ret < 0 || ret >= sizeof(nnpdev->name)) {
+		ret = -EFAULT;
+		goto err_exit;
+	}
+
+	nnpdev->hw_handle = hw_handle;
+	nnpdev->hw_device_info = hw_device_info;
+	nnpdev->hw_ops = hw_ops;
+
+	kref_init(&nnpdev->ref);
+	*out_nnpdev = nnpdev;
+
+	nnp_log_debug(START_UP_LOG, "Created NNP-I device %u\n", nnpdev->id);
+
+	return 0;
+
+err_exit:
+	if (-1 != nnpdev->id)
+		ida_simple_remove(&s_dev_ida, nnpdev->id);
+	kfree(nnpdev);
+	nnp_log_err(START_UP_LOG, "create device failed\n");
+	return ret;
+}
+
+void nnpdrv_card_doorbell_value_changed(struct nnp_device *nnpdev,
+					u32                doorbell_val)
+{
+	nnp_log_debug(GENERAL_LOG,
+		      "Got card doorbell value 0x%x\n", doorbell_val);
+}
+
+int nnpdrv_device_destroy(struct nnp_device *nnpdev, bool prepare_only)
+{
+	struct completion completion;
+	u32 id = nnpdev->id;
+
+	if (prepare_only) {
+		nnp_log_debug(GO_DOWN_LOG, "Prepare device Destroy sph device %u\n", nnpdev->id);
+
+		return 0;
+	}
+
+	nnp_log_debug(GO_DOWN_LOG, "Destroying NNP-I device %u\n", nnpdev->id);
+
+	/*
+	 * Decrement nnp_device refcount and wait until
+	 * all clients get disconnected, refcount reaches 0 and nnp_device
+	 * is released and freed
+	 */
+	init_completion(&completion);
+	nnpdev->release_completion = &completion;
+	nnpdrv_device_put(nnpdev);
+	nnp_log_info(GO_DOWN_LOG, "Waiting device %u clients to exit\n", id);
+	wait_for_completion(&completion);
+	nnp_log_info(GO_DOWN_LOG, "Device %u destroy done\n", id);
+
+	return 0;
+}
+
+static void nnpdrv_free_device(struct work_struct *work)
+{
+	struct nnp_device *nnpdev = container_of(work,
+						 struct nnp_device,
+						 free_work);
+
+	struct completion *completion = nnpdev->release_completion;
+
+	nnp_log_debug(GO_DOWN_LOG, "Freeing NNP-I device %u\n", nnpdev->id);
+
+	NNP_ASSERT(nnpdev->release_completion);
+
+	ida_simple_remove(&s_dev_ida, nnpdev->id);
+
+	kfree(nnpdev);
+	complete(completion);
+}
+
+static void release_nnp_device(struct kref *kref)
+{
+	struct nnp_device *nnpdev = container_of(kref,
+						 struct nnp_device,
+						 ref);
+
+	/*
+	 * schedule work item to actually free the device since
+	 * the device refcount can reach zero from within nnpdev->wq work item.
+	 * This will cause dead-lock since we try to flush and destroy that
+	 * workqueue when freeing the device.
+	 */
+	INIT_WORK(&nnpdev->free_work, nnpdrv_free_device);
+	queue_work(system_wq, &nnpdev->free_work);
+}
+
+void nnpdrv_device_get(struct nnp_device *nnpdev)
+{
+	int ret;
+
+	ret = kref_get_unless_zero(&nnpdev->ref);
+	WARN_ON(!ret);
+}
+
+int nnpdrv_device_put(struct nnp_device *nnpdev)
+{
+	return kref_put(&nnpdev->ref, release_nnp_device);
+}
diff --git a/drivers/misc/intel-nnpi/device.h b/drivers/misc/intel-nnpi/device.h
new file mode 100644
index 0000000..ca6d36b
--- /dev/null
+++ b/drivers/misc/intel-nnpi/device.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+#ifndef _NNPDRV_DEVICE_H
+#define _NNPDRV_DEVICE_H
+
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <linux/kref.h>
+#include <linux/completion.h>
+#include <linux/idr.h>
+#include "pcie.h"
+
+#define NNP_MAX_DEVS		32
+#define DEVICE_NAME_LEN         32
+
+struct nnp_device {
+	struct kref    ref;
+	void          *hw_handle;
+	const struct nnp_hw_device_info   *hw_device_info;
+	const struct nnpdrv_device_hw_ops *hw_ops;
+	struct completion *release_completion;
+	struct work_struct free_work;
+
+	u32             id;
+	char           name[DEVICE_NAME_LEN];
+};
+
+int nnpdrv_device_init(void);
+void nnpdrv_device_fini(void);
+
+int nnpdrv_device_create(void                              *hw_handle,
+			 const struct nnp_hw_device_info   *hw_device_info,
+			 const struct nnpdrv_device_hw_ops *hw_ops,
+			 struct nnp_device                **out_nnpdev);
+
+void nnpdrv_device_get(struct nnp_device *nnpdev);
+int nnpdrv_device_put(struct nnp_device *nnpdev);
+
+void nnpdrv_card_doorbell_value_changed(struct nnp_device *nnpdev,
+					u32                doorbell_val);
+
+int nnpdrv_device_destroy(struct nnp_device *nnpdev, bool prepare_only);
+
+int nnpdrv_device_process_messages(struct nnp_device *nnpdev,
+				   u64               *msg,
+				   u32                size);
+
+#endif
diff --git a/drivers/misc/intel-nnpi/if_include/nnp_boot_defs.h b/drivers/misc/intel-nnpi/if_include/nnp_boot_defs.h
new file mode 100644
index 0000000..ff52c18
--- /dev/null
+++ b/drivers/misc/intel-nnpi/if_include/nnp_boot_defs.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#ifndef _NNP_DOORBELL_H
+#define _NNP_DOORBELL_H
+
+/*
+ * Value fields of card->host doorbell status register HOST_PCI_DOORBELL_VALUE
+ */
+#define NNP_CARD_BOOT_STATE_MASK            0xff
+#define NNP_CARD_BOOT_STATE_SHIFT           0
+#define NNP_CARD_BIOS_UPDATE_COUNTER_MASK   0xf00
+#define NNP_CARD_BIOS_UPDATE_COUNTER_SHIFT  8
+#define NNP_CARD_ERROR_MASK                 0xf000
+#define NNP_CARD_ERROR_SHIFT                12
+#define NNP_CARD_KEEP_ALIVE_MASK            0x00f00000
+#define NNP_CARD_KEEP_ALIVE_SHIFT           20
+
+/* Possible values for card boot state */
+/* bios has not yet initialized */
+#define NNP_CARD_BOOT_STATE_NOT_READY       0
+/* bios initilaized and waiting for os boot image over pci */
+#define NNP_CARD_BOOT_STATE_BIOS_READY      1
+/* recovery bios initilaized and waiting for capsule update over pci */
+#define NNP_CARD_BOOT_STATE_RECOVERY_BIOS_READY 2
+/* bios copied boot image successfully, os boot has started */
+#define NNP_CARD_BOOT_STATE_BOOT_STARTED    3
+/* card has booted and card driver has loaded */
+#define NNP_CARD_BOOT_STATE_DRV_READY       4
+/* card driver finished initialization and user space daemon has started */
+#define NNP_CARD_BOOT_STATE_CARD_READY      8
+/* bios copied data into the system info structure */
+#define NNP_CARD_BOOT_STATE_BIOS_SYSINFO_READY 10
+/* bios capsule update has started flashing the bios image */
+#define NNP_CARD_BOOT_STATE_BIOS_FLASH_STARTED 0x20
+
+/* Possible card error values */
+#define NNP_CARD_ERROR_HOST_ERROR           1
+#define NNP_CARD_ERROR_BOOT_PARAMS          2
+#define NNP_CARD_ERROR_IMAGE_COPY           3
+#define NNP_CARD_ERROR_CORRUPTED_IMAGE      4
+#define NNP_CARD_ERROR_NOT_CAPSULE          8
+#define NNP_CARD_ERROR_CAPSULE_FAILED       9
+/*
+ * Value fields of host->card doorbell status register PCI_HOST_DOORBELL_VALUE
+ */
+#define NNP_HOST_BOOT_STATE_MASK            0xf
+#define NNP_HOST_BOOT_STATE_SHIFT           0
+#define NNP_HOST_ERROR_MASK                 0xf0
+#define NNP_HOST_ERROR_SHIFT                4
+#define NNP_HOST_DRV_STATE_MASK             0xf00
+#define NNP_HOST_DRV_STATE_SHIFT            8
+#define NNP_HOST_DRV_REQUEST_SELF_RESET_MASK  0x10000
+#define NNP_HOST_DRV_REQUEST_SELF_RESET_SHIFT 16
+#define NNP_HOST_KEEP_ALIVE_MASK            0x00f00000
+#define NNP_HOST_KEEP_ALIVE_SHIFT           20
+#define NNP_HOSY_P2P_POKE_MASK              0xff000000
+#define NNP_HOSY_P2P_POKE_SHIFT             24
+
+/* Possible values for host boot state */
+/* boot/bios image is not loaded yet to memory */
+#define NNP_HOST_BOOT_STATE_IMAGE_NOT_READY         0
+/* host driver is up and ready */
+#define NNP_HOST_BOOT_STATE_DRV_READY               (0x1 | 0x8)
+/* debug os image is loaded and ready in memory */
+#define NNP_HOST_BOOT_STATE_DEBUG_OS_IMAGE_READY    (0x2 | 0x8)
+/* bios image is loaded and ready in memory */
+#define NNP_HOST_BOOT_STATE_BIOS_IMAGE_READY        (0x3 | 0x8)
+/* debug bios image is loaded and ready in memory */
+#define NNP_HOST_BOOT_STATE_DEBUG_BIOS_IMAGE_READY  (0x4 | 0x8)
+
+/* Possible values for host error */
+#define NNP_HOST_ERROR_CANNOT_LOAD_IMAGE     1
+
+/* Possible values for host driver state */
+/* driver did not detected the device yet */
+#define NNP_HOST_DRV_STATE_NOT_READY         0
+/* driver initialized and ready */
+#define NNP_HOST_DRV_STATE_READY             1
+/* host/card protocol version mismatch */
+#define NNP_HOST_DRV_STATE_VERSION_ERROR     2
+
+#endif
diff --git a/drivers/misc/intel-nnpi/if_include/nnp_debug.h b/drivers/misc/intel-nnpi/if_include/nnp_debug.h
new file mode 100644
index 0000000..7f8e093
--- /dev/null
+++ b/drivers/misc/intel-nnpi/if_include/nnp_debug.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#ifndef _NNP_KERNEL_DEBUG_H
+#define _NNP_KERNEL_DEBUG_H
+
+#define NNP_STATIC_ASSERT(x, s) static_assert((x), s)
+
+#ifdef _DEBUG
+#define NNP_ASSERT(x)						\
+	do {							\
+		if (likely(x))					\
+			break;					\
+		pr_err("NNP ASSERTION FAILED %s: %s: %u: %s\n", \
+			__FILE__, __func__, __LINE__, #x);      \
+		WARN();                                         \
+	} while (0)
+
+#else
+#define NNP_ASSERT(x)
+
+#endif /* _DEBUG */
+
+#endif
diff --git a/drivers/misc/intel-nnpi/if_include/nnp_elbi.h b/drivers/misc/intel-nnpi/if_include/nnp_elbi.h
new file mode 100644
index 0000000..aaf4524
--- /dev/null
+++ b/drivers/misc/intel-nnpi/if_include/nnp_elbi.h
@@ -0,0 +1,151 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+#ifndef _NNP_ELBI_H
+#define _NNP_ELBI_H
+
+#include <linux/bitops.h>
+
+/*
+ * Macros for accessing bit fields according to mask and shift
+ */
+#define ELBI_BF_GET(regval, mask, shift)       (((regval) & (mask)) >> (shift))
+#define ELBI_BF_VAL(val, mask, shift)          (((val) << (shift)) & (mask))
+#define ELBI_BF_SET(regval, val, mask, shift)   \
+	((regval) = (((regval) & ~(mask)) |     \
+		     ELBI_BF_VAL((val), (mask), (shift))))
+
+#define ELBI_LINE_BDF                         (ELBI_BASE + 0x4)
+
+/*
+ * COMMAND FIFO registers
+ */
+#define ELBI_COMMAND_WRITE_WO_MSI_LOW         (ELBI_BASE + 0x50)
+#define ELBI_COMMAND_WRITE_WO_MSI_HIGH        (ELBI_BASE + 0x54)
+#define ELBI_COMMAND_WRITE_W_MSI_LOW          (ELBI_BASE + 0x58)
+#define ELBI_COMMAND_WRITE_W_MSI_HIGH         (ELBI_BASE + 0x5C)
+
+#define ELBI_COMMAND_FIFO_0_LOW		 (ELBI_BASE + 0x80)
+#define ELBI_COMMAND_FIFO_LOW(i)         (ELBI_COMMAND_FIFO_0_LOW + (i) * 8)
+#define ELBI_COMMAND_FIFO_HIGH(i)        (ELBI_COMMAND_FIFO_0_LOW + (i) * 8 + 4)
+#define ELBI_COMMAND_FIFO_DEPTH          16
+
+#define ELBI_COMMAND_IOSF_CONTROL                         (ELBI_BASE + 0x44)
+#define ELBI_COMMAND_IOSF_CONTROL_READ_POINTER_MASK       GENMASK(3, 0)
+#define ELBI_COMMAND_IOSF_CONTROL_READ_POINTER_SHIFT      0
+#define ELBI_COMMAND_IOSF_CONTROL_WRITE_POINTER_MASK      GENMASK(12, 8)
+#define ELBI_COMMAND_IOSF_CONTROL_WRITE_POINTER_SHIFT     8
+#define ELBI_COMMAND_IOSF_CONTROL_ALMOST_FULL_TH_MASK     GENMASK(19, 16)
+#define ELBI_COMMAND_IOSF_CONTROL_ALMOST_FULL_TH_SHIFT    16
+#define ELBI_COMMAND_IOSF_CONTROL_FLUSH_MASK              BIT(24)
+
+#define ELBI_COMMAND_PCI_CONTROL                          (ELBI_BASE + 0x48)
+#define ELBI_COMMAND_PCI_CONTROL_ALMOST_EMPTY_TH_MASK     GENMASK(3, 0)
+#define ELBI_COMMAND_PCI_CONTROL_ALMOST_EMPTY_TH_SHIFT    0
+#define ELBI_COMMAND_PCI_CONTROL_FLUSH_MASK               BIT(8)
+
+/*
+ * RESPONSE FIFO registers
+ */
+#define ELBI_RESPONSE_WRITE_WO_MSI_LOW        (ELBI_BASE + 0x68)
+#define ELBI_RESPONSE_WRITE_WO_MSI_HIGH       (ELBI_BASE + 0x6C)
+#define ELBI_RESPONSE_WRITE_W_MSI_LOW         (ELBI_BASE + 0x70)
+#define ELBI_RESPONSE_WRITE_W_MSI_HIGH        (ELBI_BASE + 0x74)
+
+#define ELBI_RESPONSE_FIFO_0_LOW        (ELBI_BASE + 0x100)
+#define ELBI_RESPONSE_FIFO_LOW(i)       (ELBI_RESPONSE_FIFO_0_LOW + (i) * 8)
+#define ELBI_RESPONSE_FIFO_HIGH(i)      (ELBI_RESPONSE_FIFO_0_LOW + (i) * 8 + 4)
+#define ELBI_RESPONSE_FIFO_DEPTH        16
+
+#define ELBI_RESPONSE_PCI_CONTROL                       (ELBI_BASE + 0x60)
+#define ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_MASK     GENMASK(3, 0)
+#define ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_SHIFT    0
+#define ELBI_RESPONSE_PCI_CONTROL_WRITE_POINTER_MASK    GENMASK(12, 8)
+#define ELBI_RESPONSE_PCI_CONTROL_WRITE_POINTER_SHIFT   8
+#define ELBI_RESPONSE_PCI_CONTROL_ALMOST_FULL_TH_MASK   GENMASK(19, 16)
+#define ELBI_RESPONSE_PCI_CONTROL_ALMOST_FULL_TH_SHIFT  16
+#define ELBI_RESPONSE_PCI_CONTROL_FLUSH_MASK            BIT(24)
+
+#define ELBI_RESPONSE_IOSF_CONTROL                       (ELBI_BASE + 0x64)
+#define ELBI_RESPONSE_IOSF_CONTROL_ALMOST_EMPTY_TH_MASK  GENAMSK(3, 0)
+#define ELBI_RESPONSE_IOSF_CONTROL_ALMOST_EMPTY_TH_SHIFT 0
+#define ELBI_RESPONSE_IOSF_CONTROL_FLUSH_MASK            BIT(8)
+
+/*
+ * Host side interrupt status & mask register
+ */
+#define ELBI_PCI_STATUS                       (ELBI_BASE + 0x8)
+#define ELBI_PCI_MSI_MASK                     (ELBI_BASE + 0xC)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_EMPTY_MASK               BIT(0)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_ALMOST_EMPTY_MASK        BIT(1)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_READ_UPDATE_MASK         BIT(2)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_FLUSH_MASK               BIT(3)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_WRITE_ERROR_MASK         BIT(4)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_FULL_MASK               BIT(5)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_ALMOST_FULL_MASK        BIT(6)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_NEW_RESPONSE_MASK       BIT(7)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_FLUSH_MASK              BIT(8)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_READ_ERROR_MASK         BIT(9)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_READ_POINTER_ERROR_MASK BIT(10)
+#define ELBI_PCI_STATUS_DOORBELL_MASK                         BIT(11)
+#define ELBI_PCI_STATUS_DOORBELL_READ_MASK                    BIT(12)
+#define ELBI_PCI_STATUS_FLR_REQUEST_MASK                      BIT(13)
+#define ELBI_PCI_STATUS_LOCAL_D3_MASK                         BIT(14)
+#define ELBI_PCI_STATUS_LOCAL_FLR_MASK                        BIT(15)
+
+#define ELBI_IOSF_STATUS                                   (ELBI_BASE + 0x10)
+#define ELBI_IOSF_MSI_MASK                                 (ELBI_BASE + 0x14)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_FULL_MASK              BIT(0)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_ALMOST_FULL_MASK       BIT(1)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_NEW_COMMAND_MASK       BIT(2)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_FLUSH_MASK             BIT(3)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_READ_ERROR_MASK        BIT(4)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_READ_POINTER_ERROR_MASK BIT(5)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_EMPTY_MASK            BIT(6)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_ALMOST_EMPTY_MASK     BIT(7)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_READ_UPDATE_MASK      BIT(8)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_FLUSH_MASK            BIT(9)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_WRITE_ERROR_MASK      BIT(10)
+#define ELBI_IOSF_STATUS_DOORBELL_MASK                       BIT(11)
+#define ELBI_IOSF_STATUS_DOORBELL_READ_MASK                  BIT(12)
+#define ELBI_IOSF_STATUS_LINE_D3_MASK                        BIT(13)
+#define ELBI_IOSF_STATUS_D_STATE_CHANGE_MASK                 BIT(14)
+#define ELBI_IOSF_STATUS_LINE_FLR_MASK                       BIT(15)
+#define ELBI_IOSF_STATUS_HOT_RESET_MASK                      BIT(16)
+#define ELBI_IOSF_STATUS_PME_TURN_OFF_MASK                   BIT(17)
+#define ELBI_IOSF_STATUS_PERST_B_MASK                        BIT(18)
+#define ELBI_IOSF_STATUS_PERST_ASSERTION_MASK                BIT(19)
+#define ELBI_IOSF_STATUS_DMA_INT_MASK                        BIT(20)
+#define ELBI_IOSF_STATUS_LINE_BME_MASK                       BIT(21)
+#define ELBI_IOSF_STATUS_BME_CHANGE_MASK                     BIT(22)
+#define ELBI_IOSF_STATUS_D0I3_COMPLETE_MASK                  BIT(23)
+#define ELBI_IOSF_STATUS_RST_LOAD_PHY_RECIPE_MASK            BIT(24)
+#define ELBI_IOSF_STATUS_RST_LOAD_PHY_FW_MSK                 BIT(25)
+#define ELBI_IOSF_STATUS_RST_START_PEP_MASK                  BIT(26)
+
+/* DOORBELL registers */
+#define ELBI_PCI_HOST_DOORBELL_VALUE                        (ELBI_BASE + 0x34)
+#define ELBI_HOST_PCI_DOORBELL_VALUE                        (ELBI_BASE + 0x38)
+
+/* CPU_STATUS registers */
+/* CPU_STATUS_0 - Updated by bios with postcode */
+#define ELBI_CPU_STATUS_0                                   (ELBI_BASE + 0x1b8)
+/* CPU_STATUS_1 - Updated by bios with bios flash progress */
+#define ELBI_CPU_STATUS_1                                   (ELBI_BASE + 0x1bc)
+/* CPU_STATUS_2 - Updated by card driver - bitfields below */
+#define ELBI_CPU_STATUS_2                                   (ELBI_BASE + 0x1c0)
+/* CPU_STATUS_3 - not used */
+#define ELBI_CPU_STATUS_3                                   (ELBI_BASE + 0x1c4)
+
+/* Bitfields updated in ELBI_CPU_STATUS_2 indicating card driver states */
+/*
+ * FLR_MODE_MASK 0 == warm reset
+ *               1 == cold reset
+ *               2 == ignore FLR (will not reset the card)
+ */
+#define ELBI_CPU_STATUS_2_FLR_MODE_MASK                     GENMASK(1, 0)
+#define ELBI_CPU_STATUS_2_FLR_MODE_SHIFT                    0
+
+#endif
diff --git a/drivers/misc/intel-nnpi/if_include/nnp_inbound_mem.h b/drivers/misc/intel-nnpi/if_include/nnp_inbound_mem.h
new file mode 100644
index 0000000..5cb8c16
--- /dev/null
+++ b/drivers/misc/intel-nnpi/if_include/nnp_inbound_mem.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#ifndef _NNP_INBOUND_MEM_H
+#define _NNP_INBOUND_MEM_H
+
+#include <linux/types.h>
+
+#ifndef NNP_PAGE_SHIFT
+#define NNP_PAGE_SHIFT 12
+#endif
+
+/* The crash dump buffer size is PAGE-SIZE*2^NNP_CRASH_DUMP_SIZE_PAGE_ORDER or
+ * 2^(PAGE_SHIFT+NNP_CRASH_DUMP_SIZE_PAGE_ORDER)
+ */
+#define NNP_CRASH_DUMP_SIZE_PAGE_ORDER 2
+
+#define NNP_INBOUND_MEM_MAGIC  0x4d687073  /* value of 'sphM' */
+#define NNP_CRASH_DUMP_SIZE   \
+	(1lu << (NNP_PAGE_SHIFT + NNP_CRASH_DUMP_SIZE_PAGE_ORDER))
+#define NNP_CRASH_DUMP_SIZE_PAGES    (NNP_CRASH_DUMP_SIZE >> NNP_PAGE_SHIFT)
+#pragma pack(push, 1)
+
+union nnp_inbound_mem {
+	struct {
+		__le32  magic;
+		__le32  crash_dump_size;
+		__u8	crash_dump[];
+	};
+	__u8 row[NNP_CRASH_DUMP_SIZE];
+};
+
+#pragma pack(pop)
+
+#endif
diff --git a/drivers/misc/intel-nnpi/nnp_log.h b/drivers/misc/intel-nnpi/nnp_log.h
new file mode 100644
index 0000000..3dec528
--- /dev/null
+++ b/drivers/misc/intel-nnpi/nnp_log.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#ifndef _NNP_LOG_H
+#define _NNP_LOG_H
+
+#include <linux/printk.h>
+#include <linux/dev_printk.h>
+
+/*  log categories */
+#define GENERAL_LOG "NNPLOG_GENERAL"
+#define START_UP_LOG "NNPLOG_START_UP"
+#define GO_DOWN_LOG "NNPLOG_GO_DOWN"
+
+#define nnp_log_debug(category, fmt, arg...) \
+	pr_debug(KBUILD_MODNAME ", " category " , DEBUG, %s: " fmt, \
+		 __func__, ##arg)
+
+#define nnp_log_info(category, fmt, arg...)  \
+	pr_info(KBUILD_MODNAME ", " category " , INFO, %s: " fmt, \
+		__func__, ##arg)
+
+#define nnp_log_warn(category, fmt, arg...)  \
+	pr_warn(KBUILD_MODNAME ", " category " , WARNING, %s: " fmt, \
+		__func__, ##arg)
+
+#define nnp_log_err(category, fmt, arg...)   \
+	pr_err(KBUILD_MODNAME ", " category " , ERROR, %s: " fmt, \
+	       __func__, ##arg)
+
+#define nnp_dev_debug(dev, category, fmt, arg...) \
+	dev_dbg(dev, KBUILD_MODNAME ", " category " , DEBUG, %s: " fmt, \
+		__func__, ##arg)
+
+#define nnp_dev_info(dev, category, fmt, arg...)  \
+	dev_info(dev, KBUILD_MODNAME ", " category " , INFO, %s: " fmt, \
+		 __func__, ##arg)
+
+#define nnp_dev_warn(dev, category, fmt, arg...)  \
+	dev_warn(dev, KBUILD_MODNAME ", " category " , WARNING, %s: " fmt, \
+		 __func__, ##arg)
+
+#define nnp_dev_err(dev, category, fmt, arg...)   \
+	dev_err(dev, KBUILD_MODNAME ", " category " , ERROR, %s: " fmt, \
+		__func__, ##arg)
+
+#endif
diff --git a/drivers/misc/intel-nnpi/nnp_time.h b/drivers/misc/intel-nnpi/nnp_time.h
new file mode 100644
index 0000000..be3a30f
--- /dev/null
+++ b/drivers/misc/intel-nnpi/nnp_time.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#ifndef _NNP_TIME_H
+#define _NNP_TIME_H
+
+#include <linux/kernel.h>
+#include <linux/time.h>
+#include <linux/ktime.h>
+#include <linux/timekeeping.h>
+
+static inline u64 nnp_time_us(void)
+{
+	struct timespec64 t;
+
+	ktime_get_real_ts64(&t);
+	return ((u64)(t.tv_sec * 1000000) + (t.tv_nsec / 1000));
+};
+
+#endif
diff --git a/drivers/misc/intel-nnpi/nnpdrv_main.c b/drivers/misc/intel-nnpi/nnpdrv_main.c
new file mode 100644
index 0000000..4ec8fbb
--- /dev/null
+++ b/drivers/misc/intel-nnpi/nnpdrv_main.c
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/stringify.h>
+#include "pcie.h"
+#include "device.h"
+#include "nnp_log.h"
+
+static struct nnpdrv_device_hw_callbacks nnp_dev_callbacks = {
+	.create_nnp_device = nnpdrv_device_create,
+	.card_doorbell_value_changed = nnpdrv_card_doorbell_value_changed,
+	.destroy_nnp_device = nnpdrv_device_destroy,
+	.process_messages = nnpdrv_device_process_messages
+};
+
+static int nnpdrv_init_module(void)
+{
+	int ret = 0;
+
+	nnp_log_debug(START_UP_LOG, "init module\n");
+
+	ret = nnpdrv_device_init();
+	if (ret)
+		return ret;
+
+	ret = nnpdrv_pci_init(&nnp_dev_callbacks);
+	if (ret) {
+		nnp_log_err(START_UP_LOG, "failed to init pcie\n");
+		ret = -ENODEV;
+		goto err_return;
+	}
+
+	nnp_log_info(START_UP_LOG, "NNP-I host driver is up\n");
+
+	return 0;
+
+err_return:
+	return ret;
+}
+
+static void nnpdrv_cleanup(void)
+{
+	nnp_log_debug(GO_DOWN_LOG, "Cleaning Up the Module\n");
+
+	nnpdrv_hw_cleanup();
+
+	nnpdrv_device_fini();
+}
+
+module_init(nnpdrv_init_module);
+module_exit(nnpdrv_cleanup);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Intel(R) NNPI Host Driver");
+MODULE_AUTHOR("Intel Corporation");
diff --git a/drivers/misc/intel-nnpi/pcie.c b/drivers/misc/intel-nnpi/pcie.c
new file mode 100644
index 0000000..188ad7f
--- /dev/null
+++ b/drivers/misc/intel-nnpi/pcie.c
@@ -0,0 +1,855 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/kref.h>
+#include <linux/atomic.h>
+#include "pcie.h"
+#define ELBI_BASE         0  /* MMIO offset of ELBI registers */
+#include "nnp_elbi.h"
+#include "nnp_log.h"
+#include "nnp_time.h"
+#include "nnp_inbound_mem.h"
+#include "nnp_boot_defs.h"
+
+/*
+ * SpringHill PCI card identity settings
+ */
+#define NNP_PCI_DEVICE_ID		0x45c6
+#define NNP_PCI_VENDOR_ID		PCI_VENDOR_ID_INTEL
+#define NNP_PCI_DEVFN                   0
+#define NNP_PCI_MMIO_BAR                0
+#define NNP_PCI_INBOUND_MEM_BAR         2
+
+#ifdef CONFIG_64BIT
+#define USE_64BIT_MMIO
+#endif
+
+static const char nnp_driver_name[] = "nnp_pcie";
+static const struct nnpdrv_device_hw_callbacks *s_nnp_callbacks;
+
+/* interrupt mask bits we enable and handle at interrupt level */
+static u32 s_card_status_int_mask =
+		   ELBI_PCI_STATUS_COMMAND_FIFO_READ_UPDATE_MASK;
+
+/* interrupt mask bits we enable and handle at threaded interrupt level */
+static u32 s_card_status_threaded_mask =
+		   ELBI_PCI_STATUS_RESPONSE_FIFO_NEW_RESPONSE_MASK |
+		   ELBI_PCI_STATUS_DOORBELL_MASK;
+
+struct nnp_memdesc {
+	phys_addr_t   pa;
+	void __iomem *va;
+	size_t        len;
+};
+
+struct nnp_pci_device {
+	struct kref     ref;
+	struct pci_dev *pdev;
+	struct device  *dev;
+	struct nnp_device *nnpdev;
+
+	struct nnp_hw_device_info device_info;
+	struct nnp_memdesc mmio;
+	struct nnp_memdesc mem_bar;
+
+	spinlock_t      irq_lock; /* protects cmdq_free_slots calculation */
+	u64             response_buf[ELBI_RESPONSE_FIFO_DEPTH];
+	atomic_t        new_response;
+	atomic_t        doorbell_changed;
+	u32             card_doorbell_val;
+
+	spinlock_t      cmdq_lock; /* for cmdq write serialization */
+	u32             cmdq_free_slots;
+
+	u32               card_status;
+	wait_queue_head_t card_status_wait;
+	u32               cmd_read_update_count;
+
+	u32                initted;
+
+	bool               removing;
+};
+
+static int nnp_init_pci_device(struct nnp_pci_device *nnp_pci);
+static void nnp_fini_pci_device(struct nnp_pci_device *nnp_pci);
+
+static void free_nnp_pci(struct kref *kref)
+{
+	struct nnp_pci_device *nnp_pci = container_of(kref,
+						      struct nnp_pci_device,
+						      ref);
+
+	pci_set_drvdata(nnp_pci->pdev, NULL);
+	pci_dev_put(nnp_pci->pdev);
+	kfree(nnp_pci);
+}
+
+static int nnp_pci_put(struct nnp_pci_device *nnp_pci)
+{
+	return kref_put(&nnp_pci->ref, free_nnp_pci);
+}
+
+static inline void nnp_mmio_write(struct nnp_pci_device *nnp_pci,
+				  u32                    off,
+				  u32                    val)
+{
+	iowrite32(val, nnp_pci->mmio.va + off);
+}
+
+static inline u32 nnp_mmio_read(struct nnp_pci_device *nnp_pci,
+				u32               off)
+{
+	u32 ret;
+
+	ret = ioread32(nnp_pci->mmio.va + off);
+
+	return ret;
+}
+
+static inline void nnp_mmio_write_8b(struct nnp_pci_device *nnp_pci,
+				     u32                    off,
+				     u64                    val)
+{
+#ifdef USE_64BIT_MMIO
+	writeq(val, nnp_pci->mmio.va + off);
+#else
+	nnp_mmio_write(nnp_pci,
+		       off,
+		       lower_32_bits(val));
+	nnp_mmio_write(nnp_pci,
+		       off,
+		       upper_32_bits(val));
+#endif
+}
+
+static inline u64 nnp_mmio_read_8b(struct nnp_pci_device *nnp_pci,
+				   u32                    off)
+{
+#ifdef USE_64BIT_MMIO
+	u64 ret;
+
+	ret = readq(nnp_pci->mmio.va + off);
+
+	return ret;
+#else
+	u32 low, high;
+	u64 ret;
+
+	low = nnp_mmio_read(nnp_pci,
+			    ELBI_RESPONSE_FIFO_LOW(off));
+	ret = nnp_mmio_read(nnp_pci,
+			    ELBI_RESPONSE_FIFO_HIGH(off));
+	ret = (ret << 32) | low;
+	return ret;
+#endif
+}
+
+static void nnp_process_commands(struct nnp_pci_device *nnp_pci)
+{
+	u32 response_pci_control;
+	u32 read_pointer;
+	u32 write_pointer;
+	u32 avail_slots;
+	int i;
+
+	response_pci_control = nnp_mmio_read(nnp_pci,
+					     ELBI_RESPONSE_PCI_CONTROL);
+	read_pointer =
+		ELBI_BF_GET(response_pci_control,
+			    ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_MASK,
+			    ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_SHIFT);
+	write_pointer =
+		ELBI_BF_GET(response_pci_control,
+			    ELBI_RESPONSE_PCI_CONTROL_WRITE_POINTER_MASK,
+			    ELBI_RESPONSE_PCI_CONTROL_WRITE_POINTER_SHIFT);
+	if (read_pointer > write_pointer) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "Mismatched read and write pointers\n");
+		return;
+	}
+
+	/* Commands to read */
+	avail_slots = write_pointer - read_pointer;
+
+	if (!avail_slots)
+		return;
+
+	for (i = 0; i < avail_slots; i++) {
+		read_pointer = (read_pointer + 1) % ELBI_RESPONSE_FIFO_DEPTH;
+
+		nnp_pci->response_buf[i] =
+			nnp_mmio_read_8b(nnp_pci,
+					 ELBI_RESPONSE_FIFO_LOW(read_pointer));
+	}
+
+	/*
+	 * HW restriction - we cannot update the read pointer with the same
+	 * value it currently have. This will be the case if we need to advance
+	 * it by FIFO_DEPTH locations. In this case we will update it in two
+	 * steps, first advance by 1, then to the proper value.
+	 */
+	if (avail_slots == ELBI_COMMAND_FIFO_DEPTH) {
+		u32 next_read_pointer =
+			(read_pointer + 1) % ELBI_RESPONSE_FIFO_DEPTH;
+
+		ELBI_BF_SET(response_pci_control,
+			    next_read_pointer,
+			    ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_MASK,
+			    ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_SHIFT);
+		nnp_mmio_write(nnp_pci,
+			       ELBI_RESPONSE_PCI_CONTROL,
+			       response_pci_control);
+	}
+
+	ELBI_BF_SET(response_pci_control,
+		    read_pointer,
+		    ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_MASK,
+		    ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_SHIFT);
+	nnp_mmio_write(nnp_pci,
+		       ELBI_RESPONSE_PCI_CONTROL,
+		       response_pci_control);
+
+	if (nnp_pci->nnpdev)
+		s_nnp_callbacks->process_messages(nnp_pci->nnpdev,
+						  nnp_pci->response_buf,
+						  avail_slots);
+}
+
+static irqreturn_t interrupt_handler(int irq, void *data)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)data;
+	irqreturn_t ret;
+	unsigned long flags;
+	bool should_wake = false;
+
+	spin_lock_irqsave(&nnp_pci->irq_lock, flags);
+
+	/* clear interrupts mask */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       UINT_MAX);
+
+	nnp_pci->card_status = nnp_mmio_read(nnp_pci, ELBI_PCI_STATUS);
+
+#ifdef ULT
+	INT_STAT_INC(int_stats,
+		     (nnp_pci->card_status &
+		      (s_card_status_int_mask | s_card_status_threaded_mask)));
+#endif
+
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_STATUS,
+		       nnp_pci->card_status &
+		       (s_card_status_int_mask | s_card_status_threaded_mask));
+
+	if (nnp_pci->card_status &
+	    ELBI_PCI_STATUS_COMMAND_FIFO_READ_UPDATE_MASK) {
+		should_wake = true;
+		nnp_pci->cmd_read_update_count++;
+	}
+
+	if (nnp_pci->card_status &
+	    ELBI_PCI_STATUS_RESPONSE_FIFO_NEW_RESPONSE_MASK) {
+		atomic_set(&nnp_pci->new_response, 1);
+	}
+
+	if (nnp_pci->card_status &
+	    ELBI_PCI_STATUS_DOORBELL_MASK) {
+		nnp_pci->card_doorbell_val =
+			nnp_mmio_read(nnp_pci, ELBI_HOST_PCI_DOORBELL_VALUE);
+
+		atomic_set(&nnp_pci->doorbell_changed, 1);
+	}
+
+	if (nnp_pci->card_status & s_card_status_threaded_mask)
+		ret = IRQ_WAKE_THREAD;
+	else
+		ret = IRQ_HANDLED;
+
+	/* Enable desired interrupts */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       ~(s_card_status_int_mask | s_card_status_threaded_mask));
+
+	spin_unlock_irqrestore(&nnp_pci->irq_lock, flags);
+
+	if (should_wake)
+		wake_up_all(&nnp_pci->card_status_wait);
+
+	return ret;
+}
+
+static irqreturn_t threaded_interrupt_handler(int irq, void *data)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)data;
+
+	if (atomic_xchg(&nnp_pci->doorbell_changed, 0)) {
+		if (nnp_pci->nnpdev)
+			s_nnp_callbacks->card_doorbell_value_changed(
+						nnp_pci->nnpdev,
+						nnp_pci->card_doorbell_val);
+	}
+
+	if (atomic_xchg(&nnp_pci->new_response, 0))
+		nnp_process_commands(nnp_pci);
+
+	return IRQ_HANDLED;
+}
+
+static int nnp_setup_interrupts(struct nnp_pci_device *nnp_pci,
+				struct pci_dev        *pdev)
+{
+	int rc;
+
+	rc = pci_enable_msi(pdev);
+	if (rc) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "Error enabling MSI. rc = %d\n", rc);
+		return rc;
+	}
+
+	rc = request_threaded_irq(pdev->irq,
+				  interrupt_handler,
+				  threaded_interrupt_handler,
+				  IRQF_ONESHOT,
+				  "nnpi-msi",
+				  nnp_pci);
+	if (rc) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "Error allocating MSI interrupt\n");
+		goto err_irq_req_fail;
+	}
+
+	nnp_dev_debug(nnp_pci->dev, START_UP_LOG,
+		      "nnp_pcie MSI irq setup done\n");
+
+	return 0;
+
+err_irq_req_fail:
+	pci_disable_msi(pdev);
+	return rc;
+}
+
+static void nnp_free_interrupts(struct nnp_pci_device *nnp_pci,
+				struct pci_dev        *pdev)
+{
+	/* clear interrupts mask */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       UINT_MAX);
+	free_irq(pdev->irq, nnp_pci);
+	pci_disable_msi(pdev);
+}
+
+static int nnp_cmdq_write_mesg_nowait(struct nnp_pci_device *nnp_pci,
+				      u64                   *msg,
+				      u32                    size,
+				      u32                   *read_update_count)
+{
+	u32 cmd_iosf_control;
+	u32 read_pointer, write_pointer;
+	unsigned long flags;
+	int i;
+
+	if (!nnp_pci->initted)
+		return -ENODEV;
+
+	if (size < 1)
+		return 0;
+
+	spin_lock(&nnp_pci->cmdq_lock);
+
+	if (nnp_pci->cmdq_free_slots < size) {
+		/* read command fifo pointers and compute free slots in fifo */
+		spin_lock_irqsave(&nnp_pci->irq_lock, flags);
+		cmd_iosf_control = nnp_mmio_read(nnp_pci,
+						 ELBI_COMMAND_IOSF_CONTROL);
+		read_pointer =
+			ELBI_BF_GET(cmd_iosf_control,
+				  ELBI_COMMAND_IOSF_CONTROL_READ_POINTER_MASK,
+				  ELBI_COMMAND_IOSF_CONTROL_READ_POINTER_SHIFT);
+		write_pointer =
+			ELBI_BF_GET(cmd_iosf_control,
+				 ELBI_COMMAND_IOSF_CONTROL_WRITE_POINTER_MASK,
+				 ELBI_COMMAND_IOSF_CONTROL_WRITE_POINTER_SHIFT);
+
+		nnp_pci->cmdq_free_slots = ELBI_COMMAND_FIFO_DEPTH -
+					   (write_pointer - read_pointer);
+
+		if (nnp_pci->cmdq_free_slots < size) {
+			*read_update_count = nnp_pci->cmd_read_update_count;
+			spin_unlock_irqrestore(&nnp_pci->irq_lock, flags);
+			spin_unlock(&nnp_pci->cmdq_lock);
+			return -EAGAIN;
+		}
+		spin_unlock_irqrestore(&nnp_pci->irq_lock, flags);
+	}
+
+	/* Write all but the last message without generating msi on card */
+	for (i = 0; i < size - 1; i++) {
+		nnp_mmio_write_8b(nnp_pci,
+				  ELBI_COMMAND_WRITE_WO_MSI_LOW,
+				  msg[i]);
+	}
+
+	/* Write last message with generating interrupt on card */
+	nnp_mmio_write_8b(nnp_pci,
+			  ELBI_COMMAND_WRITE_W_MSI_LOW,
+			  msg[i]);
+
+	nnp_pci->cmdq_free_slots -= size;
+
+	spin_unlock(&nnp_pci->cmdq_lock);
+
+	return 0;
+}
+
+static int nnp_cmdq_write_mesg(void *hw_handle,
+			       u64  *msg,
+			       u32   size,
+			       u64 *timed_wait)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)hw_handle;
+	int rc;
+	u32 read_update_count = 0;
+	u64 start = 0;
+
+	rc = nnp_cmdq_write_mesg_nowait(hw_handle, msg, size,
+					&read_update_count);
+	if (rc == -EAGAIN && timed_wait) {
+		start = nnp_time_us();
+	} else if (timed_wait) {
+		*timed_wait = 0;
+		timed_wait = NULL;
+	}
+
+	while (rc == -EAGAIN) {
+		rc = wait_event_interruptible(
+			nnp_pci->card_status_wait,
+			read_update_count != nnp_pci->cmd_read_update_count ||
+			!nnp_pci->initted);
+		if (rc)
+			break;
+
+		rc = nnp_cmdq_write_mesg_nowait(hw_handle, msg, size,
+						&read_update_count);
+	}
+
+	if (timed_wait)
+		*timed_wait = nnp_time_us() - start;
+
+	if (rc)
+		nnp_dev_err(nnp_pci->dev, GENERAL_LOG,
+			    "failed to write message size %d rc=%d!!\n",
+			    size, rc);
+
+	return rc;
+}
+
+static int nnp_cmdq_flush(void *hw_handle)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)hw_handle;
+
+	if (!nnp_pci->initted)
+		return -ENODEV;
+
+	nnp_mmio_write(nnp_pci,
+		       ELBI_COMMAND_PCI_CONTROL,
+		       ELBI_COMMAND_PCI_CONTROL_FLUSH_MASK);
+
+	return 0;
+}
+
+static u32 nnp_get_card_doorbell_value(void *hw_handle)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)hw_handle;
+	u32 doorbell_val;
+
+	if (!nnp_pci->initted)
+		return 0xfffffffe;
+
+	doorbell_val = nnp_mmio_read(nnp_pci, ELBI_HOST_PCI_DOORBELL_VALUE);
+	return doorbell_val;
+}
+
+static int nnp_set_host_doorbell_value(void *hw_handle, u32 value)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)hw_handle;
+
+	if (!nnp_pci->initted)
+		return -ENODEV;
+
+	/*
+	 * The SELF_RESET bit is set only by the h/w layer,
+	 * do not allow higher layer to set it
+	 */
+	value &= ~(NNP_HOST_DRV_REQUEST_SELF_RESET_MASK);
+
+	nnp_mmio_write(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE, value);
+
+	return 0;
+}
+
+static u32 nnp_get_postcode(void *hw_handle)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)hw_handle;
+	u32 val;
+
+	if (!nnp_pci->initted)
+		return 0xfffffffe;
+
+	/* bios post-code is reported in CPU_STATUS_0 register */
+	val = nnp_mmio_read(nnp_pci, ELBI_CPU_STATUS_0);
+
+	return val;
+}
+
+static u32 nnp_get_bios_flash_progress(void *hw_handle)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)hw_handle;
+	u32 val;
+
+	if (!nnp_pci->initted)
+		return 0xfffffffe;
+
+	/* bios flash progress is reported in CPU_STATUS_1 register */
+	val = nnp_mmio_read(nnp_pci, ELBI_CPU_STATUS_1);
+
+	return val;
+}
+
+static int nnp_get_membar_addr(void *hw_handle,
+			       u64   *out_phy_addr,
+			       void **out_vaddr,
+			       size_t *out_size)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)hw_handle;
+
+	if (out_phy_addr)
+		*out_phy_addr = nnp_pci->mem_bar.pa;
+
+	if (out_vaddr)
+		*out_vaddr = nnp_pci->mem_bar.va;
+
+	if (out_size)
+		*out_size = nnp_pci->mem_bar.len;
+
+	return 0;
+}
+
+static dma_addr_t nnp_get_host_doorbell_addr(void *hw_handle)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)hw_handle;
+
+	/* Doorbell is a shared resource. For peer-to-peer we use only MSB */
+	return (nnp_pci->mmio.pa + ELBI_PCI_HOST_DOORBELL_VALUE + 3);
+}
+
+static struct nnpdrv_device_hw_ops pcie_nnp_ops = {
+	.write_mesg        = nnp_cmdq_write_mesg,
+	.flush_command_fifo = nnp_cmdq_flush,
+	.get_card_doorbell_value = nnp_get_card_doorbell_value,
+	.set_host_doorbell_value = nnp_set_host_doorbell_value,
+	.get_postcode = nnp_get_postcode,
+	.get_bios_flash_progress = nnp_get_bios_flash_progress,
+	.get_membar_addr = nnp_get_membar_addr,
+	.get_host_doorbell_addr = nnp_get_host_doorbell_addr
+};
+
+static int nnp_init_pci_device(struct nnp_pci_device *nnp_pci)
+{
+	struct pci_dev *pdev = nnp_pci->pdev;
+	u32 doorbell_val, status;
+	int rc;
+	u32 line_bdf;
+
+	/* enable device */
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "failed to enable pci device. rc=%d\n", rc);
+		return rc;
+	}
+
+	/* enable bus master capability on device */
+	pci_set_master(pdev);
+
+	rc = pci_request_regions(pdev, nnp_driver_name);
+	if (rc) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "failed to get pci regions.\n");
+		goto disable_device;
+	}
+
+	nnp_pci->mmio.pa = pci_resource_start(pdev, NNP_PCI_MMIO_BAR);
+	nnp_pci->mmio.len = pci_resource_len(pdev, NNP_PCI_MMIO_BAR);
+	nnp_pci->mmio.va = pci_ioremap_bar(pdev, NNP_PCI_MMIO_BAR);
+	if (!nnp_pci->mmio.va) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "Cannot remap MMIO BAR\n");
+		rc = -EIO;
+		goto release_regions;
+	}
+
+	/* Map inbound memory region BAR */
+	nnp_pci->mem_bar.pa = pci_resource_start(pdev, NNP_PCI_INBOUND_MEM_BAR);
+	nnp_pci->mem_bar.len = pci_resource_len(pdev, NNP_PCI_INBOUND_MEM_BAR);
+	nnp_pci->mem_bar.va = pci_ioremap_bar(pdev, NNP_PCI_INBOUND_MEM_BAR);
+	if (!nnp_pci->mem_bar.va) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "Cannot remap INBOUND_MEM BAR\n");
+		rc = -EIO;
+		goto unmap_mmio;
+	}
+
+	/*
+	 * Check that the pci link is in good state:
+	 * mmio read should return valid value.
+	 */
+	line_bdf = nnp_mmio_read(nnp_pci, ELBI_LINE_BDF);
+	if (line_bdf == 0xffffffff) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "PCIe link in bad state line_bdf=0x%x\n", line_bdf);
+		rc = -EIO;
+		goto unmap_mem_bar;
+	}
+
+	nnp_dev_info(nnp_pci->dev, GENERAL_LOG,
+		     "LINE_BDF After init 0x%x\n", line_bdf);
+
+	nnp_dev_debug(nnp_pci->dev, START_UP_LOG,
+		      "Mapped mem bar, len=0x%zx pa=0x%lx va=0x%lx\n",
+		      nnp_pci->mem_bar.len,
+		      (uintptr_t)nnp_pci->mem_bar.pa,
+		      (uintptr_t)nnp_pci->mem_bar.va);
+
+	nnp_dev_debug(nnp_pci->dev, START_UP_LOG,
+		      "nnp_pcie mmio_start is 0x%llx\n", nnp_pci->mmio.pa);
+	nnp_dev_debug(nnp_pci->dev, START_UP_LOG,
+		      "nnp_pcie mmio_len   is 0x%zx\n", nnp_pci->mmio.len);
+
+	rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
+	if (rc) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "Cannot set DMA mask\n");
+		goto unmap_mem_bar;
+	}
+
+	/* clear interrupts mask */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       UINT_MAX);
+
+	rc = nnp_setup_interrupts(nnp_pci, pdev);
+	if (rc) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "nnp_setup_interrupts failed %d\n", rc);
+		goto unmap_mem_bar;
+	}
+
+	/*
+	 * done setting up the new pci device,
+	 * add it to the set of NNP-I devices
+	 */
+	if (!nnp_pci->nnpdev) {
+		rc = s_nnp_callbacks->create_nnp_device(nnp_pci,
+							&nnp_pci->device_info,
+							&pcie_nnp_ops,
+							&nnp_pci->nnpdev);
+		if (rc) {
+			nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+				  "failed to register enumarated NNP-I device");
+			goto free_interrupts;
+		}
+	}
+
+	/* notify bios that host driver is up */
+	nnp_cmdq_flush(nnp_pci);
+	doorbell_val = nnp_mmio_read(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE);
+	doorbell_val = (doorbell_val & ~(NNP_HOST_BOOT_STATE_MASK)) |
+		NNP_HOST_BOOT_STATE_DRV_READY << NNP_HOST_BOOT_STATE_SHIFT;
+	nnp_mmio_write(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE, doorbell_val);
+
+	/* Update upper layer with current value of card doorbell value */
+	doorbell_val = nnp_mmio_read(nnp_pci, ELBI_HOST_PCI_DOORBELL_VALUE);
+	s_nnp_callbacks->card_doorbell_value_changed(nnp_pci->nnpdev,
+						     doorbell_val);
+	status = nnp_mmio_read(nnp_pci, ELBI_PCI_STATUS);
+	if (status & ELBI_PCI_STATUS_DOORBELL_MASK)
+		nnp_mmio_write(nnp_pci,
+			       ELBI_PCI_STATUS, ELBI_PCI_STATUS_DOORBELL_MASK);
+
+	/* process any exising command in the response queue */
+	nnp_process_commands(nnp_pci);
+
+	/* Enable desired interrupts */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       ~(s_card_status_int_mask | s_card_status_threaded_mask));
+
+	nnp_dev_debug(nnp_pci->dev, START_UP_LOG, "nnp_pcie init_pci done.\n");
+
+	nnp_pci->initted = true;
+	return 0;
+
+free_interrupts:
+	nnp_free_interrupts(nnp_pci, pdev);
+unmap_mem_bar:
+	iounmap(nnp_pci->mem_bar.va);
+unmap_mmio:
+	iounmap(nnp_pci->mmio.va);
+release_regions:
+	pci_release_regions(pdev);
+disable_device:
+	pci_disable_device(pdev);
+
+	return rc;
+}
+
+static void nnp_fini_pci_device(struct nnp_pci_device *nnp_pci)
+{
+	if (!nnp_pci->initted)
+		return;
+
+	nnp_pci->initted = false;
+	wake_up_all(&nnp_pci->card_status_wait);
+	nnp_free_interrupts(nnp_pci, nnp_pci->pdev);
+	iounmap(nnp_pci->mem_bar.va);
+	iounmap(nnp_pci->mmio.va);
+	pci_release_regions(nnp_pci->pdev);
+	pci_disable_device(nnp_pci->pdev);
+}
+
+static int nnp_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct nnp_pci_device *nnp_pci = NULL;
+	int rc = -ENODEV;
+
+	if (PCI_FUNC(pdev->devfn) != NNP_PCI_DEVFN) {
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "unsupported pci.devfn=%u (driver only supports pci.devfn=%u)\n",
+			    PCI_FUNC(pdev->devfn), NNP_PCI_DEVFN);
+		return -ENODEV;
+	}
+
+	nnp_pci = kzalloc(sizeof(*nnp_pci), GFP_KERNEL);
+	if (!nnp_pci) {
+		rc = -ENOMEM;
+		nnp_dev_err(nnp_pci->dev, START_UP_LOG,
+			    "nnp_pci kmalloc failed rc %d\n", rc);
+		goto do_exit;
+	}
+
+	kref_init(&nnp_pci->ref);
+	nnp_pci->pdev = pdev;
+	nnp_pci->dev = &pdev->dev;
+	pci_set_drvdata(pdev, nnp_pci);
+
+	nnp_pci->device_info.hw_device = nnp_pci->dev;
+	nnp_pci->device_info.pci_slot = PCI_SLOT(pdev->devfn);
+	nnp_pci->device_info.pci_bus = pdev->bus->number;
+	nnp_pci->device_info.name = pci_name(pdev);
+
+	init_waitqueue_head(&nnp_pci->card_status_wait);
+	spin_lock_init(&nnp_pci->cmdq_lock);
+	spin_lock_init(&nnp_pci->irq_lock);
+
+	rc = nnp_init_pci_device(nnp_pci);
+	if (rc)
+		goto do_exit;
+
+	/*
+	 * Take refcount to the device which will be released only when
+	 * nnpi_pci struct is freed
+	 */
+	pci_dev_get(nnp_pci->pdev);
+
+	nnp_dev_debug(nnp_pci->dev, START_UP_LOG, "nnp_pcie probe done.\n");
+
+	return 0;
+
+do_exit:
+	if (nnp_pci)
+		nnp_fini_pci_device(nnp_pci);
+	kfree(nnp_pci);
+	pci_set_drvdata(pdev, NULL);
+	nnp_dev_err(nnp_pci->dev, START_UP_LOG, "Probe failed rc %d\n", rc);
+	return rc;
+}
+
+static void nnp_remove(struct pci_dev *pdev)
+{
+	struct nnp_pci_device *nnp_pci = NULL;
+
+	nnp_pci = pci_get_drvdata(pdev);
+	if (!nnp_pci)
+		return;
+
+	nnp_pci->removing = true;
+
+	/* inform card that host driver is down */
+	if (nnp_pci->initted)
+		nnp_mmio_write(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE, 0);
+
+	s_nnp_callbacks->destroy_nnp_device(nnp_pci->nnpdev, true);
+	nnp_fini_pci_device(nnp_pci);
+	s_nnp_callbacks->destroy_nnp_device(nnp_pci->nnpdev, false);
+
+	nnp_pci_put(nnp_pci);
+}
+
+static const struct pci_device_id nnp_pci_tbl[] = {
+	{PCI_DEVICE(NNP_PCI_VENDOR_ID, NNP_PCI_DEVICE_ID)},
+	/* required last entry */
+	{ 0, }
+};
+
+static struct pci_driver nnp_driver = {
+	.name = nnp_driver_name,
+	.id_table = nnp_pci_tbl,
+	.probe = nnp_probe,
+	.remove = nnp_remove
+};
+
+int nnpdrv_pci_init(struct nnpdrv_device_hw_callbacks *nnp_callbacks)
+{
+	int ret;
+
+	nnp_log_debug(START_UP_LOG, "nnp_pci hw_init\n");
+
+	if (!nnp_callbacks)
+		return -EINVAL;
+
+	s_nnp_callbacks = nnp_callbacks;
+
+	ret = pci_register_driver(&nnp_driver);
+	if (ret) {
+		nnp_log_err(START_UP_LOG,
+			    "pci_register_driver failed ret %d\n", ret);
+		goto error;
+	}
+
+	return ret;
+
+error:
+	nnp_log_err(START_UP_LOG, "init failed ret %d\n", ret);
+	return ret;
+}
+
+void nnpdrv_hw_cleanup(void)
+{
+	nnp_log_debug(GO_DOWN_LOG, "Cleanup");
+	pci_unregister_driver(&nnp_driver);
+	s_nnp_callbacks = NULL;
+}
+
diff --git a/drivers/misc/intel-nnpi/pcie.h b/drivers/misc/intel-nnpi/pcie.h
new file mode 100644
index 0000000..3fafec9
--- /dev/null
+++ b/drivers/misc/intel-nnpi/pcie.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+#ifndef _NNPDRV_PCIE_H
+#define _NNPDRV_PCIE_H
+
+#include <linux/version.h>
+
+struct nnp_device;
+struct device;
+
+#define NNP_MAX_COMMAND_HWQ_DEPTH    16
+#define NNP_MAX_RESPONSE_HWQ_DEPTH   16
+
+struct nnp_hw_device_info {
+	struct device *hw_device;
+	int            pci_bus;
+	int            pci_slot;
+	const char    *name;
+};
+
+/*
+ * Functions implemented by the nnp "pci" layer,
+ * called by the nnp "device" layer
+ */
+struct nnpdrv_device_hw_ops {
+	int (*write_mesg)(void *hw_handle, u64 *msg, u32 size, u64 *timed_wait);
+	int (*flush_command_fifo)(void *hw_handle);
+	u32 (*get_card_doorbell_value)(void *hw_handle);
+	int (*set_host_doorbell_value)(void *hw_handle, u32 value);
+	u32 (*get_postcode)(void *hw_handle);
+	u32 (*get_bios_flash_progress)(void *hw_handle);
+	int (*get_membar_addr)(void *hw_handle,
+			       u64   *out_phy_addr,
+			       void **out_vaddr,
+			       size_t  *out_len);
+	dma_addr_t (*get_host_doorbell_addr)(void *hw_handle);
+};
+
+/*
+ * Functions implemented by the nnp "device" layer,
+ * called by the nnp "pci" layer
+ */
+struct nnpdrv_device_hw_callbacks {
+	int (*create_nnp_device)(void                              *hw_handle,
+				 const struct nnp_hw_device_info   *hw_dev_info,
+				 const struct nnpdrv_device_hw_ops *hw_ops,
+				 struct nnp_device                **out_nnpdev);
+
+	int (*destroy_nnp_device)(struct nnp_device *nnpdev, bool prepare_only);
+
+	void (*card_doorbell_value_changed)(struct nnp_device *nnpdev,
+					    u32                doorbell_val);
+
+	int (*process_messages)(struct nnp_device *nnpdev,
+				u64               *msg,
+				u32                size);
+};
+
+int nnpdrv_pci_init(struct nnpdrv_device_hw_callbacks *callbacks);
+void nnpdrv_hw_cleanup(void);
+
+#endif
-- 
1.8.3.1

