From 58a375beabf33ef626b2b5c7114a7d331424bdb2 Mon Sep 17 00:00:00 2001
From: Guy Zadicario <guy.zadicario@intel.com>
Date: Tue, 21 Apr 2020 14:15:00 +0300
Subject: [PATCH v7 08/17] misc: nnpi: device chardev + command channel

This adds a character device for each NNP-I device (/dev/nnpi%d) with IOCTL
interface which allows user-space to generate a "command channel"
object through which user-space can send command direcly to the
message scheduler for submission to the device. As well as receive
responses arrived from the device.

Each created channel creates an anon file descriptor, user-space sends commands
to the device by writing to that file. responses from the device can be read from
that file and the channel is destroyed when the file is closed.

The IOCTL interface for that character device is in: include/uapi/misc/intel_nnpi.h

When creating a "command channel", the user should give an open file descriptor
to the /dev/nnpi_host device, this file descriptor associate the channel with
particular "nnp_user" object. The channel can only reference host resources created
by that "user".

Signed-off-by: Guy Zadicario <guy.zadicario@intel.com>
Reviewed-by: Vaibhav Agarwal <vaibhav.agarwal@intel.com>
---
 drivers/misc/intel-nnpi/Makefile                   |   3 +-
 drivers/misc/intel-nnpi/cmd_chan.c                 | 567 +++++++++++++++++++++
 drivers/misc/intel-nnpi/cmd_chan.h                 |  96 ++++
 drivers/misc/intel-nnpi/device.c                   | 312 ++++++++++++
 drivers/misc/intel-nnpi/device.h                   |  11 +
 drivers/misc/intel-nnpi/device_chardev.c           | 326 ++++++++++++
 drivers/misc/intel-nnpi/device_chardev.h           |  31 ++
 .../misc/intel-nnpi/ipc_include/ipc_c2h_events.h   | 198 +++++++
 drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h |   1 +
 drivers/misc/intel-nnpi/nnpdrv_main.c              |   8 +
 include/uapi/misc/intel_nnpi.h                     |  62 +++
 11 files changed, 1614 insertions(+), 1 deletion(-)
 create mode 100644 drivers/misc/intel-nnpi/cmd_chan.c
 create mode 100644 drivers/misc/intel-nnpi/cmd_chan.h
 create mode 100644 drivers/misc/intel-nnpi/device_chardev.c
 create mode 100644 drivers/misc/intel-nnpi/device_chardev.h
 create mode 100644 drivers/misc/intel-nnpi/ipc_include/ipc_c2h_events.h

diff --git a/drivers/misc/intel-nnpi/Makefile b/drivers/misc/intel-nnpi/Makefile
index c153e7b..4cc16f54 100644
--- a/drivers/misc/intel-nnpi/Makefile
+++ b/drivers/misc/intel-nnpi/Makefile
@@ -7,6 +7,7 @@
 obj-m	:= intel_nnpidrv.o
 
 intel_nnpidrv-y := nnpdrv_main.o pcie.o device.o msg_scheduler.o \
-		   hostres.o host_chardev.o nnp_user.o bootimage.o
+		   hostres.o host_chardev.o nnp_user.o bootimage.o \
+                   device_chardev.o cmd_chan.o
 
 ccflags-y += -I$(srctree)/$(src)/ipc_include
diff --git a/drivers/misc/intel-nnpi/cmd_chan.c b/drivers/misc/intel-nnpi/cmd_chan.c
new file mode 100644
index 0000000..0f42dea
--- /dev/null
+++ b/drivers/misc/intel-nnpi/cmd_chan.c
@@ -0,0 +1,567 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#define pr_fmt(fmt)   KBUILD_MODNAME ": %s, " fmt, __func__
+
+#include "cmd_chan.h"
+#include <linux/anon_inodes.h>
+#include <linux/dev_printk.h>
+#include <linux/file.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include "host_chardev.h"
+#include "ipc_c2h_events.h"
+#include "ipc_protocol.h"
+
+#define RESPQ_BUF_SIZE    2048   /* must be power of 2 */
+
+#define USER_MIN_OPCODE (NNP_IPC_C2H_OPCODE_LAST + 1)
+
+static inline int is_cmd_chan_file(struct file *f);
+
+static int cmd_chan_file_release(struct inode *inode, struct file *f)
+{
+	struct nnpdrv_cmd_chan *chan = f->private_data;
+	struct file *host_file;
+
+	if (!is_cmd_chan_file(f))
+		return -EINVAL;
+
+	nnpdrv_cmd_chan_send_destroy(chan);
+
+	host_file = chan->host_file;
+	nnpdrv_cmd_chan_put(chan);
+	fput(host_file);
+
+	return 0;
+}
+
+static inline int respq_avail_bytes(struct nnpdrv_cmd_chan *chan)
+{
+	return CIRC_CNT(chan->respq.head, chan->respq.tail, RESPQ_BUF_SIZE);
+}
+
+static inline int respq_free_bytes(struct nnpdrv_cmd_chan *chan)
+{
+	return CIRC_SPACE(chan->respq.head, chan->respq.tail, RESPQ_BUF_SIZE);
+}
+
+static inline void respq_push(struct nnpdrv_cmd_chan *chan,
+			      char                   *buf,
+			      int                     count)
+{
+	char *dst = chan->respq.buf + chan->respq.head;
+	int t = CIRC_SPACE_TO_END(chan->respq.head, chan->respq.tail,
+				  RESPQ_BUF_SIZE);
+
+	if (t >= count) {
+		memcpy(dst, buf, count);
+	} else {
+		memcpy(dst, buf, t);
+		memcpy(chan->respq.buf, buf + t, count - t);
+	}
+	chan->respq.head = (chan->respq.head + count) & (RESPQ_BUF_SIZE - 1);
+}
+
+static inline void respq_pop(struct nnpdrv_cmd_chan *chan,
+			     char                   *buf,
+			     int                     count)
+{
+	char *src = chan->respq.buf + chan->respq.tail;
+	int t = CIRC_CNT_TO_END(chan->respq.head, chan->respq.tail,
+				  RESPQ_BUF_SIZE);
+
+	if (t >= count) {
+		memcpy(buf, src, count);
+	} else {
+		memcpy(buf, src, t);
+		memcpy(buf + t, chan->respq.buf, count - t);
+	}
+	chan->respq.tail = (chan->respq.tail + count) & (RESPQ_BUF_SIZE - 1);
+}
+
+/**
+ * cmd_chan_file_read - reads a single response message arrived from device
+ *
+ * @f: cmd_chan file descriptor
+ * @buf: buffer to receive the message
+ * @size: size of buf, must be at least 16 qwords (16 * sizeof(u64))
+ * @off: ignored.
+ *
+ * This function will block and wait until interrupted or a response
+ * message from device is available.
+ * When message(s) are available, it reads a single message, copy it to
+ * @buf and returns the message size.
+ * the givven @buf and @size must be large enough to receive the largest
+ * possible message which is 16 qwords, otherwise -EINVAL is returned.
+ *
+ * Return: if positive, the size in bytes of the read message,
+ *         error code otherwise
+ */
+static ssize_t cmd_chan_file_read(struct file *f,
+				  char __user *buf,
+				  size_t       size,
+				  loff_t      *off)
+{
+	struct nnpdrv_cmd_chan *chan = f->private_data;
+	u32 packet_size;
+	u64 msg[16];  /* maximum possible message in the response queue */
+	int ret;
+
+	if (!is_cmd_chan_file(f))
+		return -EINVAL;
+
+	if (size < sizeof(msg))
+		return -EINVAL;
+
+	/*
+	 * wait for response message to be available.
+	 * Also wake if we signaled to be "closing" or interrupted
+	 */
+	ret = wait_event_interruptible(chan->resp_waitq,
+				       chan->closing ||
+				       respq_avail_bytes(chan) > sizeof(u32));
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * we are not serializing accesses to chan->closing since
+	 * it can only change from 0 to 1 and never back.
+	 * since we are already awake, it is OK if it changes after this
+	 * check, the user will get it on the next read call.
+	 */
+	if (chan->closing)
+		return 0;
+
+	spin_lock_bh(&chan->resp_lock_bh);
+
+	respq_pop(chan, (u8 *)&packet_size, sizeof(u32));
+	/* Check packet_size does not overrun msg size */
+	if (packet_size > sizeof(msg))
+		return -EINVAL;
+	respq_pop(chan, (u8 *)msg, packet_size);
+
+	spin_unlock_bh(&chan->resp_lock_bh);
+
+	ret = copy_to_user(buf, msg, packet_size);
+	if (ret)
+		return -EFAULT;
+
+	return packet_size;
+}
+
+/**
+ * cmd_chan_file_write - schedule a command message to be sent to the device.
+ *
+ * @f: a cmd_chan file descriptor
+ * @buf: the command message content
+ * @size: size in bytes of the message, must be multiple of 8 and not larger
+ *        than 3 qwords. one exception is "closing" message, see description.
+ * @off: ignored
+ *
+ * This function reads a command message from buffer and puts it in the
+ * channel's message queue to schedule it to be delivered to the device.
+ * The function returns when the message is copied to the message scheduler
+ * queue without waiting for it to be sent out.
+ * A valid command message size must be qword aligned and not larger than
+ * the maximum size the message scheduler support, which is 3 qwords.
+ *
+ * The function also validate the command content and fail if the chan_id
+ * field of the command header does not belong to the same channel of this
+ * file descriptor, or the command opcode is out of range, or the command
+ * size does not fit the size of this opcode.
+ *
+ * A special "closing" message can be written when size==1 and first byte
+ * in buf equal 4. This "closing" message is not sent to the device, it
+ * flags that the channel is about to be closed and no messages can be
+ * read or written to any more.
+ *
+ * Return: the size of the message written or error code.
+ */
+static ssize_t cmd_chan_file_write(struct file       *f,
+				   const char __user *buf,
+				   size_t             size,
+				   loff_t            *off)
+{
+	struct nnpdrv_cmd_chan *chan = f->private_data;
+	u64 msg[MSG_SCHED_MAX_MSG_SIZE];
+	union h2c_chan_msg_header *hdr;
+	unsigned int op;
+	int ret;
+
+	if (!is_cmd_chan_file(f))
+		return -EINVAL;
+
+	if (chan->closing)
+		return 0;
+
+	if (size == 1) {
+		u8 b;
+
+		ret = copy_from_user(&b, buf, 1);
+		if (ret != 0)
+			return -EFAULT;
+
+		if (b == 4) {
+			nnpdrv_cmd_chan_set_closing(chan);
+			return 1;
+		}
+	}
+
+	/*
+	 * size must be multiple of 8 bytes and cannot exceed maximum message
+	 * size
+	 */
+	if ((size > MSG_SCHED_MAX_MSG_SIZE * 8) ||
+	    (size &  0x7) != 0)
+		return -EINVAL;
+
+	ret = copy_from_user(msg, buf, size);
+	if (ret != 0)
+		return -EFAULT;
+
+	/*
+	 * Check chan_id, opcode and message size are valid
+	 */
+	hdr = (union h2c_chan_msg_header *)&msg[0];
+	if (hdr->chan_id != chan->protocol_id)
+		return -EINVAL;
+	if (hdr->opcode < USER_MIN_OPCODE)
+		return -EINVAL;
+	op = hdr->opcode - USER_MIN_OPCODE;
+	if (size != (chan->nnpdev->ipc_chan_cmd_op_size[op] * 8))
+		return -EINVAL;
+
+	if (!is_card_fatal_drv_event(
+				chan->card_critical_error.event_code))
+		ret  = msg_scheduler_queue_add_msg(chan->cmdq,
+						   msg,
+						   size / 8);
+	else
+		ret = -EPIPE;
+
+	if (ret < 0)
+		return ret;
+	else
+		return size;
+}
+
+static unsigned int cmd_chan_file_poll(struct file              *f,
+				       struct poll_table_struct *pt)
+{
+	struct nnpdrv_cmd_chan *chan = f->private_data;
+	unsigned int mask = (POLLOUT | POLLWRNORM);
+
+	if (!is_cmd_chan_file(f))
+		return 0;
+
+	poll_wait(f, &chan->resp_waitq, pt);
+	spin_lock_bh(&chan->resp_lock_bh);
+	if (respq_avail_bytes(chan) > sizeof(u32))
+		mask |= (POLLIN | POLLRDNORM);
+	spin_unlock_bh(&chan->resp_lock_bh);
+
+	return mask;
+}
+
+static const struct file_operations nnpdrv_cmd_chan_fops = {
+	.owner = THIS_MODULE,
+	.release = cmd_chan_file_release,
+	.read = cmd_chan_file_read,
+	.write = cmd_chan_file_write,
+	.poll = cmd_chan_file_poll
+};
+
+static inline int is_cmd_chan_file(struct file *f)
+{
+	return f->f_op == &nnpdrv_cmd_chan_fops;
+}
+
+/**
+ * nnpdrv_cmd_chan_create - creates a command channel object
+ *
+ * @nnpdev: the device
+ * @host_fd: opened file descriptor to "/dev/nnpi_host"
+ * @weight: message queue weight in message scheduler for this channel
+ * @min_id: minimum range for allocating ipc channel id for that channel
+ * @max_id: maximum range for allocating ipc channel id for that channel
+ * @get_device_events: true if this channel needs to receive device-level
+ *                     responses (not originated to specific channel).
+ * @out_cmd_chan: returns a pointer to the created command channel object.
+ *
+ * Return: error code or zero on success.
+ */
+int nnpdrv_cmd_chan_create(struct nnp_device       *nnpdev,
+			   int                      host_fd,
+			   u32                      weight,
+			   unsigned int             min_id,
+			   unsigned int             max_id,
+			   bool                     get_device_events,
+			   struct nnpdrv_cmd_chan **out_cmd_chan)
+{
+	struct nnpdrv_cmd_chan *cmd_chan;
+	int protocol_id;
+	int ret;
+	unsigned int max_proto_id = BIT(NNP_IPC_CHANNEL_BITS) - 1;
+
+	if (min_id > max_proto_id)
+		return -EINVAL;
+	if (max_id > max_proto_id)
+		max_id = max_proto_id;
+	if (max_id < min_id)
+		return -EINVAL;
+
+	ret = ida_simple_get(&nnpdev->cmd_chan_ida,
+			     min_id,
+			     max_id,
+			     GFP_KERNEL);
+	if (ret < 0)
+		return ret;
+	protocol_id = ret;
+
+	cmd_chan = kzalloc(sizeof(*cmd_chan), GFP_KERNEL);
+	if (!cmd_chan) {
+		ret = -ENOMEM;
+		goto err_ida;
+	}
+
+	cmd_chan->respq_buf = kmalloc(RESPQ_BUF_SIZE, GFP_KERNEL);
+	if (!cmd_chan->respq_buf) {
+		ret = -ENOMEM;
+		goto err_alloc;
+	}
+	cmd_chan->respq.buf = cmd_chan->respq_buf;
+
+	cmd_chan->host_file = nnpdrv_host_file_get(host_fd);
+	if (!cmd_chan->host_file) {
+		ret = -EINVAL;
+		goto err_respq;
+	}
+
+	cmd_chan->cmdq = nnpdrv_create_cmd_queue(nnpdev, weight);
+	if (!cmd_chan->cmdq) {
+		ret = -ENOMEM;
+		goto err_file_get;
+	}
+
+	kref_init(&cmd_chan->ref);
+	cmd_chan->protocol_id = protocol_id;
+	nnpdrv_device_get(nnpdev);
+	cmd_chan->nnpdev = nnpdev;
+	cmd_chan->fd = -1;
+	cmd_chan->get_device_events = get_device_events;
+
+	cmd_chan->nnp_user = cmd_chan->host_file->private_data;
+	nnp_user_get(cmd_chan->nnp_user);
+
+	init_waitqueue_head(&cmd_chan->resp_waitq);
+	spin_lock_init(&cmd_chan->resp_lock_bh);
+
+	spin_lock_init(&cmd_chan->lock);
+
+	/*
+	 * Add channel to the channel hash
+	 */
+	spin_lock(&nnpdev->lock);
+	hash_add(nnpdev->cmd_chan_hash,
+		 &cmd_chan->hash_node,
+		 cmd_chan->protocol_id);
+
+	/*
+	 * Channel with id <= 255 is an inference context channel
+	 */
+	if (cmd_chan->protocol_id <= 255)
+		nnpdev->num_active_contexts++;
+	spin_unlock(&nnpdev->lock);
+
+	*out_cmd_chan = cmd_chan;
+
+	return 0;
+
+err_file_get:
+	fput(cmd_chan->host_file);
+err_respq:
+	kfree(cmd_chan->respq_buf);
+err_alloc:
+	kfree(cmd_chan);
+err_ida:
+	ida_simple_remove(&nnpdev->cmd_chan_ida, protocol_id);
+	return ret;
+}
+
+static void nnpdrv_cmd_chan_release(struct kref *kref)
+{
+	struct nnpdrv_cmd_chan *cmd_chan;
+	struct nnp_device *nnpdev;
+
+	cmd_chan = container_of(kref, struct nnpdrv_cmd_chan, ref);
+	nnpdev = cmd_chan->nnpdev;
+
+	msg_scheduler_queue_flush(cmd_chan->cmdq);
+	nnpdrv_destroy_cmd_queue(nnpdev, cmd_chan->cmdq);
+
+	spin_lock(&nnpdev->lock);
+	hash_del(&cmd_chan->hash_node);
+	/*
+	 * Channel with id <= 255 is an inference context channel
+	 */
+	if (cmd_chan->protocol_id <= 255)
+		nnpdev->num_active_contexts--;
+	spin_unlock(&nnpdev->lock);
+	ida_simple_remove(&cmd_chan->nnpdev->cmd_chan_ida,
+			  cmd_chan->protocol_id);
+
+	if (cmd_chan->fd < 0)
+		fput(cmd_chan->host_file);
+
+	nnp_user_put(cmd_chan->nnp_user);
+
+	kfree(cmd_chan->respq_buf);
+	kfree(cmd_chan);
+
+	nnpdrv_device_put(nnpdev);
+}
+
+bool nnpdrv_cmd_chan_get(struct nnpdrv_cmd_chan *cmd_chan)
+{
+	int ret;
+
+	ret = kref_get_unless_zero(&cmd_chan->ref);
+	return ret != 0;
+}
+
+int nnpdrv_cmd_chan_put(struct nnpdrv_cmd_chan *cmd_chan)
+{
+	return kref_put(&cmd_chan->ref, nnpdrv_cmd_chan_release);
+}
+
+void nnpdrv_cmd_chan_set_closing(struct nnpdrv_cmd_chan *cmd_chan)
+{
+	if (!cmd_chan->closing) {
+		cmd_chan->closing = 1;
+		wake_up_all(&cmd_chan->resp_waitq);
+	}
+}
+
+int nnpdrv_cmd_chan_create_file(struct nnpdrv_cmd_chan *cmd_chan)
+{
+	/* this should never fail, but if it does we need to fail */
+	if (!nnpdrv_cmd_chan_get(cmd_chan))
+		return -EFAULT;
+
+	cmd_chan->fd = anon_inode_getfd("nnpi_chan",
+					&nnpdrv_cmd_chan_fops,
+					cmd_chan,
+					O_RDWR | O_CLOEXEC);
+	if (cmd_chan->fd < 0) {
+		dev_err(cmd_chan->nnpdev->dev,
+			"failed to create channel file descriptor\n");
+		nnpdrv_cmd_chan_put(cmd_chan);
+	}
+
+	return cmd_chan->fd;
+}
+
+bool nnpdrv_cmd_chan_set_destroyed(struct nnpdrv_cmd_chan *chan)
+{
+	bool ret;
+
+	spin_lock(&chan->lock);
+	ret = chan->destroyed;
+	chan->destroyed = true;
+	spin_unlock(&chan->lock);
+
+	return ret;
+}
+
+int nnpdrv_cmd_chan_send_destroy(struct nnpdrv_cmd_chan *chan)
+{
+	union h2c_channel_op msg;
+	int ret = 0;
+	bool do_put = false;
+
+	spin_lock(&chan->lock);
+	if (chan->destroyed)
+		goto done;
+
+	msg.value = 0;
+	msg.opcode = NNP_IPC_H2C_OP_CHANNEL_OP;
+	msg.protocol_id = chan->protocol_id;
+	msg.destroy = 1;
+
+	chan->event_msg.value = 0;
+
+	/*
+	 * If card is in critical state (or was during the channel lifetime)
+	 * we destroy the channel.
+	 * otherwise, we send a destroy command to card and will destroy when
+	 * the destroy reply arrives.
+	 */
+	if (is_card_fatal_drv_event(
+				chan->card_critical_error.event_code)) {
+		if (!chan->destroyed) {
+			chan->destroyed = true;
+			do_put = true;
+		}
+		goto done;
+	}
+
+	ret = nnpdrv_queue_msg(chan->nnpdev->public_cmdq, msg);
+
+done:
+	spin_unlock(&chan->lock);
+	if (do_put)
+		nnpdrv_cmd_chan_put(chan);
+	return ret;
+}
+
+/**
+ * nnpdrv_cmd_chan_add_response - adds a response message targeting this channel
+ *
+ * @cmd_chan: the command channel object
+ * @hw_msg: response message arrived from device
+ * @size: size in bytes of the response
+ *
+ * This function is being called when a response message arrived from the device
+ * which is targeted for a specific command channel object.
+ * The function puts the response message in a ring buffer and will later be
+ * consumed by user through a call to read(2) on the channel file descriptor.
+ * The function is called from bottom-half.
+ *
+ * Return: error code or zero on success.
+ */
+int nnpdrv_cmd_chan_add_response(struct nnpdrv_cmd_chan *cmd_chan,
+				 u64                    *hw_msg,
+				 u32                     size)
+{
+	spin_lock_bh(&cmd_chan->resp_lock_bh);
+
+	/* do we have space for the message in the current ring buffer? */
+	if (respq_free_bytes(cmd_chan) < (size + sizeof(u32))) {
+		spin_unlock_bh(&cmd_chan->resp_lock_bh);
+
+		/*
+		 * This should never happen in normal system operation since
+		 * the ring-buffer is way big than will ever needed.
+		 * We will get here only if the user application sleeps for
+		 * a very long time without draining the responses.
+		 */
+		dev_err(cmd_chan->nnpdev->dev,
+			"Response queue full for channel %d losing response!\n",
+			cmd_chan->protocol_id);
+		return -ENOMEM;
+	}
+
+	/* push the response message to the ring buffer */
+	respq_push(cmd_chan, (u8 *)&size, sizeof(u32));
+	respq_push(cmd_chan, (u8 *)hw_msg, size);
+
+	spin_unlock_bh(&cmd_chan->resp_lock_bh);
+
+	wake_up_all(&cmd_chan->resp_waitq);
+
+	return 0;
+}
diff --git a/drivers/misc/intel-nnpi/cmd_chan.h b/drivers/misc/intel-nnpi/cmd_chan.h
new file mode 100644
index 0000000..c798349
--- /dev/null
+++ b/drivers/misc/intel-nnpi/cmd_chan.h
@@ -0,0 +1,96 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#ifndef NNPDRV_CMD_CHAN_H
+#define NNPDRV_CMD_CHAN_H
+
+#include <linux/atomic.h>
+#include <linux/circ_buf.h>
+#include <linux/fs.h>
+#include <linux/hashtable.h>
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include "device.h"
+#include "ipc_protocol.h"
+#include "nnp_user.h"
+
+/**
+ * struct nnpdev_cmd_chan - structure object for user<->device communication
+ *
+ * @ref: refcount for this object
+ * @nnpdev: the device
+ * @protocol_id: the ipc channel id for this channel
+ * @hash_node: node to include this object in list of channels
+ *             hash is in (cmd_chan_hash in nnp_device).
+ * @event_msg: ipc event response received from device during create channel
+ * @card_critical_error: last critical event report received from device
+ * @get_device_events: true if device-level events received from device should
+ *                     be sent over this channel to user.
+ * @fd: file descriptor created for the channel (implements read/write)
+ * @cmdq: message queue added to msg_scheduler, for user commands to be sent
+ *        to the device.
+ * @host_file: reference to opened "/dev/nnpi_host" object which defines the
+ *             nnp_user object this channel connects to.
+ * @nnp_user: the nnp_user this channel belongs to.
+ *             the channel can reference host resources created by this
+ *             nnp_user object.
+ * @closing: when true indicate the user is about to close the channel and
+ *           new responses from device should be ignored.
+ * @lock: a lock to synchronize accesses to @destroyed
+ * @destroyed: a state indicating that the channel should be not-yet-exist on
+ *             the device.
+ * @resp_lock_bh: protects @respq
+ * @resp_waitq: waitqueue used for waiting for response messages be available.
+ * @respq: circular buffer object that receive response messages from device.
+ * @respq_buf: buffer space allocated for circular response buffer.
+ */
+struct nnpdrv_cmd_chan {
+	struct kref       ref;
+	struct nnp_device *nnpdev;
+	u16               protocol_id;
+	struct hlist_node hash_node;
+	union c2h_event_report event_msg;
+	union c2h_event_report card_critical_error;
+	bool              get_device_events;
+
+	int fd;
+	struct msg_scheduler_queue *cmdq;
+	struct file *host_file;
+	struct nnp_user_info *nnp_user;
+	int    closing;
+
+	spinlock_t        lock; /* protects destroyed */
+	wait_queue_head_t resp_waitq;
+	bool              destroyed;
+
+	spinlock_t        resp_lock_bh; /* protects respq modifications */
+	struct circ_buf   respq;
+	char             *respq_buf;
+};
+
+int nnpdrv_cmd_chan_create(struct nnp_device       *nnpdev,
+			   int                      host_fd,
+			   u32                      weight,
+			   unsigned int             min_id,
+			   unsigned int             max_id,
+			   bool                     get_device_events,
+			   struct nnpdrv_cmd_chan **out_cmd_chan);
+
+bool nnpdrv_cmd_chan_get(struct nnpdrv_cmd_chan *cmd_chan);
+int nnpdrv_cmd_chan_put(struct nnpdrv_cmd_chan *cmd_chan);
+void nnpdrv_cmd_chan_set_closing(struct nnpdrv_cmd_chan *cmd_chan);
+
+int nnpdrv_cmd_chan_create_file(struct nnpdrv_cmd_chan *cmd_chan);
+bool nnpdrv_cmd_chan_set_destroyed(struct nnpdrv_cmd_chan *chan);
+int nnpdrv_cmd_chan_send_destroy(struct nnpdrv_cmd_chan *chan);
+
+int nnpdrv_cmd_chan_add_response(struct nnpdrv_cmd_chan *cmd_chan,
+				 u64                    *hw_msg,
+				 u32                     size);
+
+#endif
diff --git a/drivers/misc/intel-nnpi/device.c b/drivers/misc/intel-nnpi/device.c
index ea01f05..c570bd0 100644
--- a/drivers/misc/intel-nnpi/device.c
+++ b/drivers/misc/intel-nnpi/device.c
@@ -18,13 +18,18 @@
 #include <linux/wait.h>
 #include <linux/workqueue.h>
 #include "bootimage.h"
+#include "cmd_chan.h"
+#include "device_chardev.h"
 #include "host_chardev.h"
+#include "ipc_c2h_events.h"
 #include "nnp_boot_defs.h"
 #include "pcie.h"
 
 static unsigned int num_devices;
 static DEFINE_MUTEX(device_num_mutex);
 
+#define BITS_PER_U64 (sizeof(u64) * 8)
+
 static int nnpdrv_first_device_init(void)
 {
 	int ret = 0;
@@ -73,6 +78,9 @@ static void process_query_version_reply(struct work_struct *work)
 	struct nnp_device *nnpdev;
 	u32 protocol_version;
 	u32 card_boot_state;
+	u64 chan_resp_op_size;
+	u64 chan_cmd_op_size;
+	int i;
 
 	query_version_work =
 		container_of(work, struct query_version_work, work);
@@ -81,6 +89,18 @@ static void process_query_version_reply(struct work_struct *work)
 	card_boot_state = (nnpdev->card_doorbell_val &
 		       NNP_CARD_BOOT_STATE_MASK) >> NNP_CARD_BOOT_STATE_SHIFT;
 
+	chan_resp_op_size = query_version_work->chan_resp_op_size;
+	for (i = 0; i < BITS_PER_U64 / 2; i++) {
+		nnpdev->ipc_chan_resp_op_size[i] = (chan_resp_op_size & 0x3);
+		chan_resp_op_size >>= 2;
+	}
+
+	chan_cmd_op_size = query_version_work->chan_cmd_op_size;
+	for (i = 0; i < BITS_PER_U64 / 2; i++) {
+		nnpdev->ipc_chan_cmd_op_size[i] = (chan_cmd_op_size & 0x3);
+		chan_cmd_op_size >>= 2;
+	}
+
 	pr_debug("Got DriverReady message, ipcProtocolVer=%d.%d.%d chan_protocol_ver=%d.%d.%d\n",
 		 NNP_VERSION_MAJOR(query_version_work->protocol_version),
 		 NNP_VERSION_MINOR(query_version_work->protocol_version),
@@ -239,6 +259,213 @@ static int handle_bios_protocol(struct nnp_device         *nnpdev,
 	return msg_qwords;
 }
 
+struct nnpdrv_cmd_chan *nnpdrv_device_find_channel(struct nnp_device *nnpdev,
+						   u16              protocol_id)
+{
+	struct nnpdrv_cmd_chan *cmd_chan;
+
+	spin_lock(&nnpdev->lock);
+	hash_for_each_possible(nnpdev->cmd_chan_hash,
+			       cmd_chan,
+			       hash_node,
+			       protocol_id)
+		if (cmd_chan->protocol_id == protocol_id) {
+			if (!nnpdrv_cmd_chan_get(cmd_chan))
+				break;
+			spin_unlock(&nnpdev->lock);
+			return cmd_chan;
+		}
+	spin_unlock(&nnpdev->lock);
+
+	return NULL;
+}
+
+static struct nnpdrv_cmd_chan *undestroyed_channel(struct nnp_device *nnpdev)
+{
+	struct nnpdrv_cmd_chan *cmd_chan;
+	int i;
+
+	spin_lock(&nnpdev->lock);
+	hash_for_each(nnpdev->cmd_chan_hash,
+		      i,
+		      cmd_chan,
+		      hash_node) {
+		if (!nnpdrv_cmd_chan_set_destroyed(cmd_chan)) {
+			spin_unlock(&nnpdev->lock);
+			return cmd_chan;
+		}
+	}
+	spin_unlock(&nnpdev->lock);
+
+	return NULL;
+}
+
+static void nnpdrv_destroy_all_channels(struct nnp_device *nnpdev)
+{
+	struct nnpdrv_cmd_chan *cmd_chan;
+
+	/*
+	 * re-iterate on all channel hash until it does not include any
+	 * channel which does not yet marked destroyed.
+	 */
+	cmd_chan = undestroyed_channel(nnpdev);
+	while (cmd_chan) {
+		nnpdrv_cmd_chan_put(cmd_chan);
+		cmd_chan = undestroyed_channel(nnpdev);
+	}
+}
+
+void nnpdrv_submit_device_event_to_channels(struct nnp_device *nnpdev,
+					    union c2h_event_report *event_msg,
+					    bool                   force)
+{
+	struct nnpdrv_cmd_chan *cmd_chan;
+	int i;
+
+	spin_lock(&nnpdev->lock);
+	hash_for_each(nnpdev->cmd_chan_hash,
+		      i,
+		      cmd_chan,
+		      hash_node) {
+		if (is_card_fatal_event(event_msg->event_code) &&
+		    !is_card_fatal_drv_event(
+				cmd_chan->card_critical_error.event_code)) {
+			cmd_chan->card_critical_error.value = event_msg->value;
+			wake_up_all(&nnpdev->waitq);
+		}
+
+		if (force || cmd_chan->get_device_events)
+			nnpdrv_cmd_chan_add_response(cmd_chan,
+						     (u64 *)event_msg,
+						     sizeof(*event_msg));
+	}
+	spin_unlock(&nnpdev->lock);
+
+	/*
+	 * On card fatal event, we consider the device dead and there is
+	 * no point communicating with it. The user will destroy the context
+	 * and initiate a device reset to fix this.
+	 * We destroy all channels here since the NNP_IPC_CHANNEL_DESTROYED
+	 * response, which normally do that, will never arrive.
+	 */
+	if (is_card_fatal_drv_event(event_msg->event_code))
+		nnpdrv_destroy_all_channels(nnpdev);
+}
+
+/*
+ * this function handle device-level event report message.
+ * which is usually affect the entire device and not a single channel
+ */
+static void nnpdrv_process_device_event(struct nnp_device *nnpdev,
+				union c2h_event_report *event_msg)
+{
+	struct nnpdrv_cmd_chan *cmd_chan;
+
+	if (is_card_fatal_event(event_msg->event_code)) {
+		nnpdrv_submit_device_event_to_channels(nnpdev, event_msg, true);
+	} else {
+		switch (event_msg->event_code) {
+		case NNP_IPC_CREATE_CHANNEL_SUCCESS:
+		case NNP_IPC_CREATE_CHANNEL_FAILED:
+			cmd_chan = nnpdrv_device_find_channel(nnpdev,
+							     event_msg->obj_id);
+			if (!cmd_chan) {
+				pr_err("Got channel create reply for not existing channel %d\n",
+				       event_msg->obj_id);
+			} else {
+				cmd_chan->event_msg.value = event_msg->value;
+				nnpdrv_cmd_chan_put(cmd_chan);
+				wake_up_all(&nnpdev->waitq);
+			}
+			break;
+		case NNP_IPC_DESTROY_CHANNEL_FAILED:
+			pr_err("Channel destroyed failed channel %d val %d\n",
+			       event_msg->obj_id, event_msg->event_val);
+			fallthrough;
+		case NNP_IPC_CHANNEL_DESTROYED:
+			cmd_chan = nnpdrv_device_find_channel(nnpdev,
+							     event_msg->obj_id);
+			if (!cmd_chan) {
+				pr_err("Got channel destroyed reply for not existing channel %d\n",
+				       event_msg->obj_id);
+			} else {
+				/*
+				 * put twice - one for the get made by find, one
+				 */
+				if (!nnpdrv_cmd_chan_set_destroyed(cmd_chan))
+					nnpdrv_cmd_chan_put(cmd_chan);
+				nnpdrv_cmd_chan_set_closing(cmd_chan);
+				nnpdrv_cmd_chan_put(cmd_chan);
+			}
+			break;
+		default:
+			pr_err("Unknown event received - %u\n",
+			       event_msg->event_code);
+			return;
+		}
+
+		nnpdrv_submit_device_event_to_channels(nnpdev,
+						       event_msg, false);
+	}
+}
+
+struct event_report_work {
+	struct work_struct work;
+	struct nnp_device    *nnpdev;
+	union c2h_event_report msg;
+};
+
+static void device_event_report_handler(struct work_struct *work)
+{
+	struct event_report_work *req = container_of(work,
+						    struct event_report_work,
+						    work);
+
+	nnpdrv_process_device_event(req->nnpdev, &req->msg);
+
+	kfree(req);
+}
+
+static int handle_event_report(struct nnp_device         *nnpdev,
+			       const void                *msgbuf,
+			       int                        avail_qwords)
+{
+	const union c2h_event_report *event_msg = msgbuf;
+	struct event_report_work *req;
+
+	int msg_qwords = sizeof(*event_msg) / sizeof(u64);
+
+	if (avail_qwords < msg_qwords)
+		return 0;
+
+	if (event_msg->ctx_valid) {
+		struct nnpdrv_cmd_chan *cmd_chan;
+
+		cmd_chan = nnpdrv_device_find_channel(nnpdev,
+						      event_msg->context_id);
+		if (cmd_chan) {
+			nnpdrv_cmd_chan_add_response(cmd_chan,
+				(u64 *)event_msg, sizeof(*event_msg));
+			nnpdrv_cmd_chan_put(cmd_chan);
+		} else {
+			pr_err("Got context Event Report for non existing context id %d\n",
+			       event_msg->context_id);
+		}
+		return msg_qwords;
+	}
+
+	req = kzalloc(sizeof(*req), GFP_NOWAIT);
+	if (!req)
+		return msg_qwords;
+
+	memcpy(&req->msg, event_msg, sizeof(*event_msg));
+	req->nnpdev = nnpdev;
+	INIT_WORK(&req->work, device_event_report_handler);
+	queue_work(nnpdev->wq, &req->work);
+
+	return msg_qwords;
+}
+
 static int handle_sys_info(struct nnp_device         *nnpdev,
 			   const void                *msgbuf,
 			   int                        avail_qwords)
@@ -271,10 +498,51 @@ typedef int (*response_handler)(struct nnp_device *nnpdev,
 	[NNP_IPC_C2H_OP_QUERY_VERSION_REPLY] = handle_query_version_reply,
 	[NNP_IPC_C2H_OP_QUERY_VERSION_REPLY2] = handle_query_version_reply2,
 	[NNP_IPC_C2H_OP_QUERY_VERSION_REPLY3] = handle_query_version_reply3,
+	[NNP_IPC_C2H_OP_EVENT_REPORT] = handle_event_report,
 	[NNP_IPC_C2H_OP_SYS_INFO] = handle_sys_info,
 	[NNP_IPC_C2H_OP_BIOS_PROTOCOL] = handle_bios_protocol
 };
 
+static int dispatch_chan_message(struct nnp_device *nnpdev,
+				 u64               *hw_msg,
+				 u32                size)
+{
+	int op_code = ((union c2h_chan_msg_header *)hw_msg)->opcode;
+	int chan_id = ((union c2h_chan_msg_header *)hw_msg)->chan_id;
+	struct nnpdrv_cmd_chan *chan;
+	int msg_size = 0;
+
+	if (op_code < 32 || op_code > 63) {
+		/* Should not happen! */
+		pr_err("chan response opcode out-of-range received %d (0x%llx)\n",
+		       op_code, *hw_msg);
+		return -EINVAL;
+	}
+
+	msg_size = nnpdev->ipc_chan_resp_op_size[op_code - 32];
+	if (msg_size == 0) {
+		/* Should not happen! */
+		pr_err("Unknown response chan opcode received %d (0x%llx)\n",
+		       op_code, *hw_msg);
+		return -EINVAL;
+	}
+
+	if (size < msg_size)
+		return -EFAULT;
+
+	chan = nnpdrv_device_find_channel(nnpdev, chan_id);
+	if (!chan) {
+		pr_err("Got response for invalid channel chan_id=%d 0x%llx\n",
+		       chan_id, *hw_msg);
+		return msg_size;
+	}
+
+	nnpdrv_cmd_chan_add_response(chan, hw_msg, msg_size * 8);
+	nnpdrv_cmd_chan_put(chan);
+
+	return msg_size;
+}
+
 /**
  * nnpdrv_device_process_messages - process response messages from nnpi device
  *
@@ -295,6 +563,7 @@ void nnpdrv_device_process_messages(struct nnp_device *nnpdev,
 	u64 *msg;
 	unsigned int nof_msg;
 	bool fatal_protocol_error = false;
+	int ret;
 
 	/* ignore any response if protocol error detected */
 	if ((nnpdev->state & NNP_DEVICE_PROTOCOL_ERROR) != 0)
@@ -330,6 +599,22 @@ void nnpdrv_device_process_messages(struct nnp_device *nnpdev,
 		int partial_msg = 0;
 		response_handler handler = resp_handlers[op_code];
 
+		/* opcodes above OP_BIOS_PROTOCOL are routed to a channel */
+		if (op_code > NNP_IPC_C2H_OP_BIOS_PROTOCOL) {
+			ret = dispatch_chan_message(nnpdev,
+						    &msg[j], (nof_msg - j));
+			if (ret > 0) {
+				j += ret;
+			} else {
+				if (ret == -EFAULT)
+					partial_msg = true;
+				else
+					fatal_protocol_error = true;
+				break;
+			}
+			continue;
+		}
+
 		/* dispatch the message request */
 		if (!handler) {
 			/* Should not happen! */
@@ -633,6 +918,12 @@ struct nnp_device *nnpdrv_device_create(struct nnp_pci_device        *hw_handle,
 
 	nnpdev->hw_handle = hw_handle;
 	nnpdev->hw_device_info = hw_dinfo;
+	nnpdev->num_ice_devices = 0;
+	nnpdev->protocol_version = 0;
+
+	ida_init(&nnpdev->cmd_chan_ida);
+	hash_init(nnpdev->cmd_chan_hash);
+	init_waitqueue_head(&nnpdev->waitq);
 
 	ret = nnpdrv_first_device_init();
 	if (ret)
@@ -686,6 +977,18 @@ struct nnp_device *nnpdrv_device_create(struct nnp_pci_device        *hw_handle,
 		(struct nnp_sys_info *)((uintptr_t)nnpdev->bios_system_info +
 					NNP_PAGE_SIZE);
 
+	/* Create the character device interface to this device */
+	ret = nnpdev_device_chardev_create(nnpdev);
+	if (ret)
+		goto err_sys_info;
+
+	/* set host driver state to "Not ready" */
+	ret = nnp_set_host_doorbell_value(nnpdev->hw_handle,
+		NNP_HOST_DRV_STATE_NOT_READY << NNP_HOST_DRV_STATE_SHIFT);
+	if (ret)
+		pr_debug("Doorbel call to set driver state ready failure rc=%d\n",
+			 ret);
+
 	kref_init(&nnpdev->ref);
 	spin_lock_init(&nnpdev->lock);
 	INIT_WORK(&nnpdev->query_version_work.work, process_query_version_reply);
@@ -694,6 +997,11 @@ struct nnp_device *nnpdrv_device_create(struct nnp_pci_device        *hw_handle,
 
 	return nnpdev;
 
+err_sys_info:
+	dma_free_coherent(nnpdev->hw_device_info->hw_device,
+			  2 * NNP_PAGE_SIZE,
+			  nnpdev->bios_system_info,
+			  nnpdev->bios_system_info_dma_addr);
 err_crash_dump:
 	dma_free_coherent(nnpdev->hw_device_info->hw_device,
 			  1lu << (NNP_PAGE_SHIFT +
@@ -888,6 +1196,9 @@ static void nnpdrv_free_device(struct work_struct *work)
 
 	pr_debug("Freeing NNP-I device %u\n", nnpdev->id);
 
+	/* destroy device character device */
+	nnpdev_device_chardev_destroy(nnpdev);
+
 	dma_free_coherent(nnpdev->hw_device_info->hw_device,
 			1 << (NNP_PAGE_SHIFT + NNP_CRASH_DUMP_SIZE_PAGE_ORDER),
 			nnpdev->host_crash_dump.vaddr,
@@ -907,6 +1218,7 @@ static void nnpdrv_free_device(struct work_struct *work)
 		pr_err("cmd queue scheduler destruction went wrong\n");
 
 	ida_simple_remove(&dev_ida, nnpdev->id);
+	ida_destroy(&nnpdev->cmd_chan_ida);
 	kfree(nnpdev);
 
 	if (WARN_ON(!completion))
diff --git a/drivers/misc/intel-nnpi/device.h b/drivers/misc/intel-nnpi/device.h
index c1f5f5b..5a3f6da 100644
--- a/drivers/misc/intel-nnpi/device.h
+++ b/drivers/misc/intel-nnpi/device.h
@@ -6,7 +6,9 @@
 #ifndef _NNPDRV_DEVICE_H
 #define _NNPDRV_DEVICE_H
 
+#include <linux/cdev.h>
 #include <linux/completion.h>
+#include <linux/hashtable.h>
 #include <linux/idr.h>
 #include <linux/kernel.h>
 #include <linux/kref.h>
@@ -83,6 +85,8 @@ struct nnp_device {
 	struct work_struct free_work;
 	struct query_version_work query_version_work;
 
+	struct cdev cdev;
+	struct device *dev;
 	struct host_crash_dump host_crash_dump;
 	struct msg_scheduler       *cmdq_sched;
 	struct msg_scheduler_queue *public_cmdq;
@@ -97,6 +101,10 @@ struct nnp_device {
 	u64            response_buf[NNP_DEVICE_RESPONSE_BUFFER_LEN];
 	u32            response_num_msgs;
 
+	struct ida cmd_chan_ida;
+	DECLARE_HASHTABLE(cmd_chan_hash, 6);
+	wait_queue_head_t waitq;
+
 	dma_addr_t                  bios_system_info_dma_addr;
 	struct nnp_c2h_system_info *bios_system_info;
 	char                        bios_version_str[NNP_BIOS_VERSION_LEN];
@@ -112,6 +120,9 @@ struct nnp_device {
 	unsigned short chan_protocol_version;
 	unsigned int   num_active_contexts;
 	u32            card_doorbell_val;
+
+	u8   ipc_chan_resp_op_size[32];
+	u8   ipc_chan_cmd_op_size[32];
 };
 
 int nnpdrv_device_init(void);
diff --git a/drivers/misc/intel-nnpi/device_chardev.c b/drivers/misc/intel-nnpi/device_chardev.c
new file mode 100644
index 0000000..79346f9
--- /dev/null
+++ b/drivers/misc/intel-nnpi/device_chardev.c
@@ -0,0 +1,326 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#define pr_fmt(fmt)   KBUILD_MODNAME ": %s, " fmt, __func__
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+#include <uapi/misc/intel_nnpi.h>
+#include "cmd_chan.h"
+#include "device_chardev.h"
+#include "ipc_c2h_events.h"
+
+static dev_t       devnum;
+static struct class *class;
+
+#define NNPDRV_DEVICE_DEV_NAME "nnpi"
+
+static inline int is_nnp_device_file(struct file *f);
+
+static int nnpdrv_device_open(struct inode *inode, struct file *f)
+{
+	struct device_client_info *client;
+
+	if (!is_nnp_device_file(f))
+		return -EINVAL;
+
+	if (!inode->i_cdev)
+		return -EINVAL;
+
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
+	if (!client)
+		return -ENOMEM;
+
+	client->nnpdev = container_of(inode->i_cdev,
+				      struct nnp_device,
+				      cdev);
+
+	f->private_data = client;
+
+	return 0;
+}
+
+static int nnpdrv_device_release(struct inode *inode, struct file *f)
+{
+	struct device_client_info *client =
+		(struct device_client_info *)f->private_data;
+
+	if (!is_nnp_device_file(f))
+		return -EINVAL;
+
+	kfree(client);
+	f->private_data = NULL;
+
+	return 0;
+}
+
+static int event_val_to_nnp_error(enum event_val event_val)
+{
+	pr_debug("Got error. event_val: %d\n", event_val);
+
+	switch (event_val) {
+	case NNP_IPC_NO_ERROR:
+		return 0;
+	case NNP_IPC_NO_MEMORY:
+		return -ENOMEM;
+	default:
+		return -EFAULT;
+	}
+}
+
+static long create_channel(struct device_client_info *cinfo,
+			   void __user *arg,
+			   unsigned int size)
+{
+	struct nnp_device *nnpdev = cinfo->nnpdev;
+	struct ioctl_nnpi_create_channel req;
+	struct nnpdrv_cmd_chan *chan;
+	union h2c_channel_op msg;
+	u32 error_mask;
+	long ret = 0;
+	unsigned int io_size = sizeof(req);
+
+	memset(&req, 0, sizeof(req));
+	if (size < io_size)
+		io_size = size;
+
+	ret = copy_from_user(&req, arg, io_size);
+	if (ret != 0)
+		return -EFAULT;
+
+	req.o_errno = 0;
+
+	if (req.i_max_id < req.i_min_id)
+		return -EINVAL;
+
+	/*
+	 * Do not allow create command channel if device is in
+	 * error state.
+	 * However allow new non infer context channels in case
+	 * of fatal ICE error in order to allow retrieve debug
+	 * information.
+	 */
+	error_mask = NNP_DEVICE_ERROR_MASK;
+	if (req.i_max_id >= 256)
+		error_mask &= ~(NNP_DEVICE_FATAL_ICE_ERROR);
+
+	if ((nnpdev->state & error_mask) ||
+	    !(nnpdev->state & NNP_DEVICE_CARD_DRIVER_READY) ||
+	    (req.i_max_id < 256 &&
+	     (nnpdev->state & NNP_DEVICE_ACTIVE_MASK) !=
+	     NNP_DEVICE_ACTIVE_MASK)) {
+		req.o_errno = NNPER_DEVICE_NOT_READY;
+		goto done;
+	}
+
+	/* Validate channel protocol version */
+	if (NNP_VERSION_MAJOR(req.i_protocol_version) !=
+	    NNP_VERSION_MAJOR(nnpdev->chan_protocol_version) ||
+	    NNP_VERSION_MINOR(req.i_protocol_version) !=
+	    NNP_VERSION_MINOR(nnpdev->chan_protocol_version)) {
+		dev_err(nnpdev->dev,
+			"Error: Protocol version mismatch between UMD and card payload\n");
+		dev_err(nnpdev->dev, "UMD protocol version %d.%d.%d\n",
+			NNP_VERSION_MAJOR(req.i_protocol_version),
+			NNP_VERSION_MINOR(req.i_protocol_version),
+			NNP_VERSION_DOT(req.i_protocol_version));
+		dev_err(nnpdev->dev, "Card protocol version %d.%d.%d\n",
+			NNP_VERSION_MAJOR(nnpdev->chan_protocol_version),
+			NNP_VERSION_MINOR(nnpdev->chan_protocol_version),
+			NNP_VERSION_DOT(nnpdev->chan_protocol_version));
+		req.o_errno = NNPER_VERSIONS_MISMATCH;
+		goto done;
+	}
+
+	ret = nnpdrv_cmd_chan_create(nnpdev,
+				     req.i_host_fd,
+				     req.i_weight,
+				     req.i_min_id,
+				     req.i_max_id,
+				     req.i_get_device_events,
+				     &chan);
+	if (ret < 0)
+		goto done;
+
+	/*
+	 * send the create request to card
+	 *
+	 * Some requests sent from user-space to the device using the command
+	 * channel should be rejected by the device if it made from
+	 * a different or un-priviledged user.
+	 * We send the uid and flag the channel privilege only for
+	 * CAP_SYS_ADMIN users. The device uses this info to reject
+	 * certain particular requests when made from other channels.
+	 */
+	msg.value = 0;
+	msg.opcode = NNP_IPC_H2C_OP_CHANNEL_OP;
+	msg.protocol_id = chan->protocol_id;
+	msg.uid = current_euid().val;
+	if (capable(CAP_SYS_ADMIN))
+		msg.privileged = 1;
+
+	ret = nnpdrv_queue_msg(nnpdev->public_cmdq, msg);
+	if (ret < 0) {
+		if (!nnpdrv_cmd_chan_set_destroyed(chan))
+			nnpdrv_cmd_chan_put(chan);
+		goto done;
+	}
+
+	ret = wait_event_interruptible(nnpdev->waitq,
+		chan->event_msg.value != 0 ||
+		is_card_fatal_drv_event(chan->card_critical_error.event_code));
+	if (chan->event_msg.value == 0) {
+		if (ret < 0) {
+			ret = -EINTR;
+			nnpdrv_cmd_chan_send_destroy(chan);
+		} else {
+			req.o_errno = NNPER_DEVICE_ERROR;
+			ret = -EFAULT;
+			if (!nnpdrv_cmd_chan_set_destroyed(chan))
+				nnpdrv_cmd_chan_put(chan);
+		}
+		goto done;
+	} else if (chan->event_msg.event_code ==
+		   NNP_IPC_CREATE_CHANNEL_FAILED) {
+		req.o_errno = event_val_to_nnp_error(chan->event_msg.event_val);
+		if (!nnpdrv_cmd_chan_set_destroyed(chan))
+			nnpdrv_cmd_chan_put(chan);
+		goto done;
+	}
+
+	req.o_channel_id = chan->protocol_id;
+
+	/*
+	 * Attach file descriptor to the channel object - if created
+	 * successfully
+	 */
+	req.o_fd = nnpdrv_cmd_chan_create_file(chan);
+
+	/* remove channel object if failed */
+	if (req.o_fd < 0) {
+		ret = req.o_fd;
+		nnpdrv_cmd_chan_send_destroy(chan);
+	}
+
+done:
+	req.o_privileged = capable(CAP_SYS_ADMIN) ? 1 : 0;
+	if (copy_to_user(arg, &req, io_size) != 0)
+		return -EFAULT;
+
+	return ret;
+}
+
+static long nnpdrv_device_ioctl(struct file  *f,
+				unsigned int  cmd,
+				unsigned long arg)
+{
+	struct device_client_info *client =
+		(struct device_client_info *)f->private_data;
+	unsigned int ioc_nr, size;
+
+	if (!is_nnp_device_file(f))
+		return -EINVAL;
+
+	if (_IOC_TYPE(cmd) != 'D')
+		return -EINVAL;
+
+	ioc_nr = _IOC_NR(cmd);
+	size = _IOC_SIZE(cmd);
+
+	switch (ioc_nr) {
+	case _IOC_NR(IOCTL_NNPI_DEVICE_CREATE_CHANNEL):
+		return create_channel(client, (void __user *)arg, size);
+	default:
+		dev_err(client->nnpdev->dev,
+			"Unsupported device IOCTL 0x%x\n", cmd);
+	}
+
+	return -EINVAL;
+}
+
+static const struct file_operations nnpdrv_device_fops = {
+	.owner = THIS_MODULE,
+	.open = nnpdrv_device_open,
+	.release = nnpdrv_device_release,
+	.unlocked_ioctl = nnpdrv_device_ioctl,
+	.compat_ioctl = nnpdrv_device_ioctl
+};
+
+static inline int is_nnp_device_file(struct file *f)
+{
+	return (f->f_op == &nnpdrv_device_fops);
+}
+
+int nnpdev_device_chardev_create(struct nnp_device *nnpdev)
+{
+	int ret;
+
+	if (!nnpdev)
+		return -EINVAL;
+
+	cdev_init(&nnpdev->cdev, &nnpdrv_device_fops);
+	nnpdev->cdev.owner = THIS_MODULE;
+	ret = cdev_add(&nnpdev->cdev,
+		       MKDEV(MAJOR(devnum), nnpdev->id),
+		       1);
+	if (ret)
+		return ret;
+
+	nnpdev->dev = device_create(class,
+				    NULL,
+				    MKDEV(MAJOR(devnum), nnpdev->id),
+				    nnpdev,
+				    NNPI_DEVICE_DEV_FMT,
+				    nnpdev->id);
+	if (IS_ERR(nnpdev->dev)) {
+		cdev_del(&nnpdev->cdev);
+		return PTR_ERR(nnpdev->dev);
+	}
+
+	return 0;
+}
+
+void nnpdev_device_chardev_destroy(struct nnp_device *nnpdev)
+{
+	if (nnpdev) {
+		device_destroy(class, MKDEV(MAJOR(devnum), nnpdev->id));
+		cdev_del(&nnpdev->cdev);
+	}
+}
+
+int nnpdev_device_chardev_init(void)
+{
+	int ret;
+
+	ret = alloc_chrdev_region(&devnum, 0,
+				  NNP_MAX_DEVS, NNPDRV_DEVICE_DEV_NAME);
+	if (ret < 0) {
+		pr_err("failed to allocate devnum %d\n", ret);
+		return ret;
+	}
+
+	class = class_create(THIS_MODULE, NNPDRV_DEVICE_DEV_NAME);
+	if (IS_ERR(class)) {
+		ret = PTR_ERR(class);
+		pr_err("failed to register class %d\n", ret);
+		unregister_chrdev_region(devnum, NNP_MAX_DEVS);
+		return ret;
+	}
+
+	return 0;
+}
+
+void nnpdev_device_chardev_cleanup(void)
+{
+	class_destroy(class);
+	unregister_chrdev_region(devnum, NNP_MAX_DEVS);
+}
+
diff --git a/drivers/misc/intel-nnpi/device_chardev.h b/drivers/misc/intel-nnpi/device_chardev.h
new file mode 100644
index 0000000..46d17dd
--- /dev/null
+++ b/drivers/misc/intel-nnpi/device_chardev.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+#ifndef _NNPDRV_DEVICE_CHARDEV_H
+#define _NNPDRV_DEVICE_CHARDEV_H
+
+#include "device.h"
+#include <linux/fs.h>
+#include <linux/list.h>
+
+struct events_report_client_info {
+	struct list_head events_list_head;
+	struct list_head node;
+};
+
+struct inf_process_info;
+
+struct device_client_info {
+	struct nnp_device *nnpdev;
+	struct file *host_file;
+	bool is_inf_client;
+};
+
+int nnpdev_device_chardev_create(struct nnp_device *nnpdev);
+void nnpdev_device_chardev_destroy(struct nnp_device *nnpdev);
+int nnpdev_device_chardev_init(void);
+void nnpdev_device_chardev_cleanup(void);
+
+#endif
diff --git a/drivers/misc/intel-nnpi/ipc_include/ipc_c2h_events.h b/drivers/misc/intel-nnpi/ipc_include/ipc_c2h_events.h
new file mode 100644
index 0000000..eb8b145
--- /dev/null
+++ b/drivers/misc/intel-nnpi/ipc_include/ipc_c2h_events.h
@@ -0,0 +1,198 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+#ifndef _NNP_IPC_C2H_EVENTS_H
+#define _NNP_IPC_C2H_EVENTS_H
+
+/**
+ * The following describes the possible values for a c2h_event_report message
+ * sent from card to host to report on some error or other events.
+ *
+ * The c2h_event_report message has the following fields available to describe
+ * the event:
+ *    event_code  - 8 bits value describing the type of event
+ *    event_val   - 8 bits value - interpetation depends on event_code
+ *    context_id  - the protocol_id of the context in which the event was
+ *                 occurred.
+ *    obj_id      - 16 bits, interpretation depends on event_code, usually used
+ *                 to hold an inference object protocol ID.
+ *    obj_id_2    - 16 bits, in case obj_id is not enough to describe the object
+ * In this file we define the possible values for the above fields and document
+ * each field meaning for each possible event_code.
+ */
+
+/**
+ * Event codes ranges
+ *
+ * Those ranges should match the definition of RuntimeEventCodes
+ * defined in include/sphcsInference.h and used by the daemon/runtime
+ * interface !!!
+ *
+ * error codes are grouped into the following ranges:
+ *     0 -   3   ==> non error events generated by daemon/runtime
+ *     4 -  47   ==> non error events generated by card kernel driver
+ *    48 -  51   ==> non-critical error events generated by daemon/runtime
+ *    52 -  95   ==> non-critical error events generatd by kernel driver
+ *    96 - 103   ==> context-critical error events generated by daemon/runtime
+ *   104 - 111   ==> context-critical error events generated by kernel driver
+ *   112 - 119   ==> card-critical error events generated by daemon/runtime
+ *   120 - 127   ==> card-critical error events generated by kernel driver
+ *
+ * context-critical error event is one that puts the infer context in an
+ * un-recovarable error state.
+ * card-critical error event is one that make the card not useful for inference
+ * request until it is reset.
+ */
+#define EVENT_NON_ERR_START             0
+#define EVENT_NON_ERR_DRV_START         4
+#define EVENT_ERR_START                48
+#define EVENT_ERR_DRV_START            52
+#define EVENT_CONTEXT_FATAL_START      96
+#define EVENT_CONTEXT_FATAL_DRV_START 104
+#define EVENT_CARD_FATAL_START        112
+#define EVENT_CARD_FATAL_DRV_START    120
+
+#define is_context_fatal_event(e)  ((e) >= EVENT_CONTEXT_FATAL_START && \
+				    (e) < EVENT_CARD_FATAL_START)
+#define is_card_fatal_event(e)     ((e) >= EVENT_CARD_FATAL_START)
+#define is_card_fatal_drv_event(e)     ((e) >= EVENT_CARD_FATAL_DRV_START)
+
+#define NNP_IPC_RUNTIME_DONE   (EVENT_NON_ERR_START + 1)
+/*            MAX offset for EVENT_NON_ERR_START is 3 */
+
+/* non-error event codes */
+#define NNP_IPC_CREATE_CONTEXT_SUCCESS   (EVENT_NON_ERR_DRV_START + 0)
+#define NNP_IPC_CREATE_DEVRES_SUCCESS    (EVENT_NON_ERR_DRV_START + 1)
+#define NNP_IPC_CREATE_COPY_SUCCESS      (EVENT_NON_ERR_DRV_START + 2)
+#define NNP_IPC_EXECUTE_COPY_SUCCESS     (EVENT_NON_ERR_DRV_START + 3)
+#define NNP_IPC_DEVRES_DESTROYED         (EVENT_NON_ERR_DRV_START + 4)
+#define NNP_IPC_COPY_DESTROYED           (EVENT_NON_ERR_DRV_START + 5)
+#define NNP_IPC_CONTEXT_DESTROYED        (EVENT_NON_ERR_DRV_START + 6)
+#define NNP_IPC_CREATE_DEVNET_SUCCESS    (EVENT_NON_ERR_DRV_START + 7)
+#define NNP_IPC_DEVNET_DESTROYED         (EVENT_NON_ERR_DRV_START + 8)
+#define NNP_IPC_CREATE_INFREQ_SUCCESS    (EVENT_NON_ERR_DRV_START + 9)
+#define NNP_IPC_INFREQ_DESTROYED         (EVENT_NON_ERR_DRV_START + 10)
+#define NNP_IPC_RECOVER_CONTEXT_SUCCESS  (EVENT_NON_ERR_DRV_START + 11)
+#define NNP_IPC_THERMAL_TRIP_EVENT       (EVENT_NON_ERR_DRV_START + 12)
+#define NNP_IPC_DEVNET_ADD_RES_SUCCESS   (EVENT_NON_ERR_DRV_START + 13)
+#define NNP_IPC_DEVICE_STATE_CHANGED     (EVENT_NON_ERR_DRV_START + 14)
+#define NNP_IPC_DEVNET_RESOURCES_RESERVATION_SUCCESS \
+	(EVENT_NON_ERR_DRV_START + 15)
+#define NNP_IPC_DEVNET_RESOURCES_RELEASE_SUCCESS  (EVENT_NON_ERR_DRV_START + 16)
+#define NNP_IPC_CREATE_CHANNEL_SUCCESS   (EVENT_NON_ERR_DRV_START + 17)
+#define NNP_IPC_CHANNEL_DESTROYED        (EVENT_NON_ERR_DRV_START + 18)
+#define NNP_IPC_CHANNEL_SET_RB_SUCCESS   (EVENT_NON_ERR_DRV_START + 19)
+#define NNP_IPC_CHANNEL_MAP_HOSTRES_SUCCESS   (EVENT_NON_ERR_DRV_START + 20)
+#define NNP_IPC_CHANNEL_UNMAP_HOSTRES_SUCCESS (EVENT_NON_ERR_DRV_START + 21)
+#define NNP_IPC_ABORT_REQUEST            (EVENT_NON_ERR_DRV_START + 22)
+#define NNP_IPC_GET_FIFO                 (EVENT_NON_ERR_DRV_START + 23)
+#define NNP_IPC_CREATE_CMD_SUCCESS       (EVENT_NON_ERR_DRV_START + 24)
+#define NNP_IPC_CMD_DESTROYED            (EVENT_NON_ERR_DRV_START + 25)
+#define NNP_IPC_EXECUTE_CMD_COMPLETE     (EVENT_NON_ERR_DRV_START + 26)
+#define NNP_IPC_DEVNET_SET_PROPERTY_SUCCESS  (EVENT_NON_ERR_DRV_START + 27)
+#define NNP_IPC_EXECUTE_CPYLST_SUCCESS   (EVENT_NON_ERR_DRV_START + 28)
+#define NNP_IPC_GET_CR_FIFO_REPLY        (EVENT_NON_ERR_DRV_START + 29)
+#define NNP_IPC_P2P_PEERS_CONNECTED      (EVENT_NON_ERR_DRV_START + 30)
+#define NNP_IPC_P2P_PEER_DEV_UPDATED     (EVENT_NON_ERR_DRV_START + 31)
+#define NNP_IPC_EXECUTE_COPY_SUBRES_SUCCESS  (EVENT_NON_ERR_DRV_START + 32)
+/*                   MAX offset for EVENT_NON_ERR_DRV_START is 43 */
+
+/* non-critical error event codes */
+#define NNP_IPC_CREATE_CONTEXT_FAILED    (EVENT_ERR_DRV_START + 0)
+#define NNP_IPC_CREATE_DEVRES_FAILED     (EVENT_ERR_DRV_START + 1)
+#define NNP_IPC_CREATE_COPY_FAILED       (EVENT_ERR_DRV_START + 2)
+#define NNP_IPC_DESTROY_CONTEXT_FAILED   (EVENT_ERR_DRV_START + 3)
+#define NNP_IPC_DESTROY_DEVRES_FAILED    (EVENT_ERR_DRV_START + 4)
+#define NNP_IPC_DESTROY_COPY_FAILED      (EVENT_ERR_DRV_START + 5)
+#define NNP_IPC_CREATE_SYNC_FAILED       (EVENT_ERR_DRV_START + 6)
+#define NNP_IPC_ERROR_SUB_RESOURCE_LOAD_FAILED      (EVENT_ERR_DRV_START + 7)
+#define NNP_IPC_CREATE_DEVNET_FAILED     (EVENT_ERR_DRV_START + 8)
+#define NNP_IPC_DESTROY_DEVNET_FAILED    (EVENT_ERR_DRV_START + 9)
+#define NNP_IPC_CREATE_INFREQ_FAILED     (EVENT_ERR_DRV_START + 10)
+#define NNP_IPC_DESTROY_INFREQ_FAILED    (EVENT_ERR_DRV_START + 11)
+#define NNP_IPC_RECOVER_CONTEXT_FAILED   (EVENT_ERR_DRV_START + 12)
+#define NNP_IPC_ERROR_MCE_CORRECTABLE    (EVENT_ERR_DRV_START + 13)
+#define NNP_IPC_ERROR_MCE_UNCORRECTABLE  (EVENT_ERR_DRV_START + 14)
+#define NNP_IPC_DEVNET_ADD_RES_FAILED    (EVENT_ERR_DRV_START + 15)
+#define NNP_IPC_DEVNET_RESOURCES_RESERVATION_FAILED (EVENT_ERR_DRV_START + 16)
+#define NNP_IPC_DEVNET_RESOURCES_RELEASE_FAILED     (EVENT_ERR_DRV_START + 17)
+#define NNP_IPC_CREATE_CHANNEL_FAILED    (EVENT_ERR_DRV_START + 18)
+#define NNP_IPC_DESTROY_CHANNEL_FAILED   (EVENT_ERR_DRV_START + 19)
+#define NNP_IPC_CHANNEL_SET_RB_FAILED    (EVENT_ERR_DRV_START + 20)
+#define NNP_IPC_CREATE_CMD_FAILED        (EVENT_ERR_DRV_START + 21)
+#define NNP_IPC_DESTROY_CMD_FAILED       (EVENT_ERR_DRV_START + 22)
+#define NNP_IPC_CHANNEL_MAP_HOSTRES_FAILED   (EVENT_ERR_DRV_START + 23)
+#define NNP_IPC_CHANNEL_UNMAP_HOSTRES_FAILED (EVENT_ERR_DRV_START + 24)
+#define NNP_IPC_DEVNET_SET_PROPERTY_FAILED  (EVENT_ERR_DRV_START + 25)
+#define NNP_IPC_ERROR_DRAM_ECC_CORRECTABLE (EVENT_ERR_DRV_START + 26)
+#define NNP_IPC_EXECUTE_COPY_FAILED        (EVENT_ERR_DRV_START + 27)
+#define NNP_IPC_SCHEDULE_INFREQ_FAILED     (EVENT_ERR_DRV_START + 28)
+#define NNP_IPC_EXECUTE_CPYLST_FAILED      (EVENT_ERR_DRV_START + 29)
+#define NNP_IPC_EXECUTE_COPY_SUBRES_FAILED  (EVENT_ERR_DRV_START + 30)
+/*                   MAX offset for EVENT_ERR_DRV_START is 43 */
+
+/* context critical error event codes */
+#define NNP_IPC_ERROR_RUNTIME_LAUNCH     (EVENT_CONTEXT_FATAL_START + 0)
+#define NNP_IPC_ERROR_RUNTIME_DIED       (EVENT_CONTEXT_FATAL_START + 1)
+/*                   MAX offset for EVENT_CONTEXT_FATAL_START is 7 */
+
+#define NNP_IPC_CONTEXT_EXEC_ERROR          (EVENT_CONTEXT_FATAL_DRV_START + 0)
+#define NNP_IPC_CTX_DRAM_ECC_UNCORRECTABLE  (EVENT_CONTEXT_FATAL_DRV_START + 1)
+/*                   MAX offset for EVENT_CONTEXT_FATAL_DRV_START is 7 */
+
+/* card critical error event codes */
+#define NNP_IPC_ERROR_OS_CRASHED          (EVENT_CARD_FATAL_START + 0)
+#define NNP_IPC_ERROR_DRAM_ECC_UNCORRECTABLE_FATAL  (EVENT_CARD_FATAL_START + 1)
+#define NNP_IPC_ERROR_FATAL_ICE_ERROR     (EVENT_CARD_FATAL_START + 2)
+/*                   MAX offset for EVENT_CARD_FATAL_START is 7 */
+
+/* card critical and driver fatal*/
+#define NNP_IPC_ERROR_PCI_ERROR           (EVENT_CARD_FATAL_DRV_START + 0)
+#define NNP_IPC_ERROR_MCE_UNCORRECTABLE_FATAL  (EVENT_CARD_FATAL_DRV_START + 1)
+#define NNP_IPC_ERROR_CARD_RESET          (EVENT_CARD_FATAL_DRV_START + 2)
+#define NNP_IPC_ERROR_CHANNEL_KILLED      (EVENT_CARD_FATAL_DRV_START + 3)
+#define NNP_IPC_ERROR_PROTOCOL_ERROR      (EVENT_CARD_FATAL_DRV_START + 4)
+/*                   MAX offset for EVENT_CARD_FATAL_DRV_START is 7 */
+
+enum event_val {
+	NNP_IPC_NO_ERROR		= 0,
+	NNP_IPC_NO_SUCH_CONTEXT		= 1,
+	NNP_IPC_NO_SUCH_DEVRES		= 2,
+	NNP_IPC_NO_SUCH_COPY		= 3,
+	NNP_IPC_NO_SUCH_NET		= 4,
+	NNP_IPC_NO_SUCH_INFREQ		= 5,
+	NNP_IPC_ALREADY_EXIST		= 6,
+	NNP_IPC_NO_DAEMON		= 7,
+	NNP_IPC_NO_MEMORY		= 8,
+	NNP_IPC_RUNTIME_FAILED		= 9,
+	NNP_IPC_RUNTIME_LAUNCH_FAILED	= 10,
+	NNP_IPC_DMA_ERROR		= 11,
+	NNP_IPC_RUNTIME_NOT_SUPPORTED	= 12,
+	NNP_IPC_RUNTIME_INVALID_EXECUTABLE_NETWORK_BINARY = 13,
+	NNP_IPC_RUNTIME_INFER_MISSING_RESOURCE        = 14,
+	NNP_IPC_RUNTIME_INFER_EXEC_ERROR              = 15,
+	NNP_IPC_RUNTIME_INFER_SCHEDULE_ERROR          = 16,
+	NNP_IPC_CONTEXT_BROKEN                        = 17,
+	NNP_IPC_DEVNET_RESERVE_INSUFFICIENT_RESOURCES = 18,
+	NNP_IPC_TIMEOUT_EXCEEDED        = 19,
+	NNP_IPC_ECC_ALLOC_FAILED        = 20,
+	NNP_IPC_NO_SUCH_CHANNEL         = 21,
+	NNP_IPC_NO_SUCH_CMD             = 22,
+	NNP_IPC_NO_SUCH_HOSTRES         = 23,
+	NNP_IPC_DEVNET_EDIT_BUSY        = 24,
+	NNP_IPC_DEVNET_EDIT_ERROR       = 25,
+	NNP_IPC_NOT_SUPPORTED           = 26,
+	NNP_IPC_ICEDRV_INFER_EXEC_ERROR = 27,
+	NNP_IPC_ICEDRV_INFER_EXEC_ERROR_NEED_RESET = 28,
+	NNP_IPC_ICEDRV_INFER_EXEC_ERROR_NEED_CARD_RESET = 29,
+	NNP_IPC_NO_EXEC_ERRORS          = 30,
+	NNP_IPC_IO_ERROR                = 31,
+	NNP_IPC_INPUT_IS_DIRTY          = 32,
+
+	/* Non failure events */
+	NNP_IPC_CMDLIST_FINISHED       = 128,
+};
+
+#endif
diff --git a/drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h b/drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h
index e90ea15..f0e9974 100644
--- a/drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h
+++ b/drivers/misc/intel-nnpi/ipc_include/ipc_protocol.h
@@ -10,6 +10,7 @@
 
 #ifdef __KERNEL__
 #include <linux/dma-mapping.h>
+#include "ipc_c2h_events.h"
 #include "nnp_inbound_mem.h"
 
 #define CHECK_MESSAGE_SIZE(t, n_qw) \
diff --git a/drivers/misc/intel-nnpi/nnpdrv_main.c b/drivers/misc/intel-nnpi/nnpdrv_main.c
index c5bd7b0..e7667d2 100644
--- a/drivers/misc/intel-nnpi/nnpdrv_main.c
+++ b/drivers/misc/intel-nnpi/nnpdrv_main.c
@@ -12,6 +12,7 @@
 #include <linux/printk.h>
 #include <linux/stringify.h>
 #include "device.h"
+#include "device_chardev.h"
 #include "pcie.h"
 
 static int nnpdrv_init_module(void)
@@ -24,6 +25,12 @@ static int nnpdrv_init_module(void)
 	if (ret)
 		return ret;
 
+	ret = nnpdev_device_chardev_init();
+	if (ret) {
+		pr_err("failed to init chardev class\n");
+		goto err_return;
+	}
+
 	ret = nnpdrv_pci_init();
 	if (ret) {
 		pr_err("failed to init pcie\n");
@@ -46,6 +53,7 @@ static void nnpdrv_cleanup(void)
 	nnpdrv_hw_cleanup();
 
 	nnpdrv_device_fini();
+	nnpdev_device_chardev_cleanup();
 }
 
 module_init(nnpdrv_init_module);
diff --git a/include/uapi/misc/intel_nnpi.h b/include/uapi/misc/intel_nnpi.h
index e1a5761..867efce 100644
--- a/include/uapi/misc/intel_nnpi.h
+++ b/include/uapi/misc/intel_nnpi.h
@@ -154,6 +154,68 @@ struct nnpdrv_ioctl_destroy_hostres {
 	__u8  o_errno;
 };
 
+/*
+ * ioctls for /dev/nnpi%d device
+ */
+#define NNPI_DEVICE_DEV_FMT "nnpi%u"
+#define IOCTL_NNPI_DEVICE_CREATE_CHANNEL      \
+	_IOWR('D', 0, struct ioctl_nnpi_create_channel)
+
+#define IOCTL_NNPI_DEVICE_CREATE_CHANNEL_RB   \
+	_IOWR('D', 1, struct ioctl_nnpi_create_channel_data_ringbuf)
+
+#define IOCTL_NNPI_DEVICE_DESTROY_CHANNEL_RB  \
+	_IOWR('D', 2, struct ioctl_nnpi_destroy_channel_data_ringbuf)
+
+#define IOCTL_NNPI_DEVICE_CHANNEL_MAP_HOSTRES \
+	_IOWR('D', 3, struct ioctl_nnpi_channel_map_hostres)
+
+#define IOCTL_NNPI_DEVICE_CHANNEL_UNMAP_HOSTRES \
+	_IOWR('D', 4, struct ioctl_nnpi_channel_unmap_hostres)
+
+struct ioctl_nnpi_create_channel {
+	__u32 i_weight;
+	__s32    i_host_fd;
+	__s32    i_min_id;
+	__s32    i_max_id;
+	__s32    i_get_device_events;
+	__u32 i_version;
+	__u16 i_protocol_version;
+	__s32    o_fd;
+	__u16 o_channel_id;
+	__s32    o_privileged;
+	__u8  o_errno;
+};
+
+struct ioctl_nnpi_create_channel_data_ringbuf {
+	__u16 i_channel_id;
+	__u8  i_id;
+	__u8  i_h2c;
+	__u64 i_hostres_handle;
+	__u8  o_errno;
+};
+
+struct ioctl_nnpi_destroy_channel_data_ringbuf {
+	__u16 i_channel_id;
+	__u8  i_id;
+	__u8  i_h2c;
+	__u8  o_errno;
+};
+
+struct ioctl_nnpi_channel_map_hostres {
+	__u16 i_channel_id;
+	__u64 i_hostres_handle;
+	__u16 o_map_id;
+	__u8  o_sync_needed;
+	__u8  o_errno;
+};
+
+struct ioctl_nnpi_channel_unmap_hostres {
+	__u16 i_channel_id;
+	__u16 i_map_id;
+	__u8  o_errno;
+};
+
 /****************************************************************
  * Error code values - errors returned in o_errno fields of
  * above structures.
-- 
1.8.3.1

