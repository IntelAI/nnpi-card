From d833197832553d999389e11cb20c608f0ba4062b Mon Sep 17 00:00:00 2001
From: Guy Zadicario <guy.zadicario@intel.com>
Date: Sat, 28 Mar 2020 17:58:39 +0300
Subject: [PATCH v7 01/17] misc: nnpi: main module init and main PCI device
 access functions

This patch includes the main module initialization, main PCI device
registration and access functions.

nnpdrv_main.c - The main module initialization and cleanup functions.
pcie.h - Defines interface between the functional "device" layer and
         the "pci" layer where all pci access functions are implemented.
pcie.c - The main pci registration and device access code.
device.c - Currently almost empty implementation of the functional "device" layer.
ipc_include/   - This directory will include h/w register definitions and protocol structures
                 used to communicate with the NNPI device. Those include files are used also
                 by the device internal s/w stack.

Signed-off-by: Guy Zadicario <guy.zadicario@intel.com>
Reviewed-by: Vaibhav Agarwal <vaibhav.agarwal@intel.com>
---
 MAINTAINERS                                        |   5 +
 drivers/misc/Kconfig                               |   1 +
 drivers/misc/Makefile                              |   1 +
 drivers/misc/intel-nnpi/Kconfig                    |  17 +
 drivers/misc/intel-nnpi/Makefile                   |  11 +
 drivers/misc/intel-nnpi/device.c                   | 220 ++++++
 drivers/misc/intel-nnpi/device.h                   |  36 +
 .../misc/intel-nnpi/ipc_include/nnp_boot_defs.h    |  86 +++
 drivers/misc/intel-nnpi/ipc_include/nnp_elbi.h     | 151 ++++
 .../misc/intel-nnpi/ipc_include/nnp_inbound_mem.h  |  36 +
 drivers/misc/intel-nnpi/nnpdrv_main.c              |  56 ++
 drivers/misc/intel-nnpi/pcie.c                     | 793 +++++++++++++++++++++
 drivers/misc/intel-nnpi/pcie.h                     |  97 +++
 13 files changed, 1510 insertions(+)
 create mode 100644 drivers/misc/intel-nnpi/Kconfig
 create mode 100644 drivers/misc/intel-nnpi/Makefile
 create mode 100644 drivers/misc/intel-nnpi/device.c
 create mode 100644 drivers/misc/intel-nnpi/device.h
 create mode 100644 drivers/misc/intel-nnpi/ipc_include/nnp_boot_defs.h
 create mode 100644 drivers/misc/intel-nnpi/ipc_include/nnp_elbi.h
 create mode 100644 drivers/misc/intel-nnpi/ipc_include/nnp_inbound_mem.h
 create mode 100644 drivers/misc/intel-nnpi/nnpdrv_main.c
 create mode 100644 drivers/misc/intel-nnpi/pcie.c
 create mode 100644 drivers/misc/intel-nnpi/pcie.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 3b186ad..cbc9c48 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -8898,6 +8898,11 @@ F:	include/uapi/linux/mic_common.h
 F:	include/uapi/linux/mic_ioctl.h
 F:	include/uapi/linux/scif_ioctl.h
 
+INTEL NNP-I PCI DRIVER
+M:	Guy Zadicario <guy.zadicario@intel.com>
+S:	Supported
+F:	drivers/misc/intel-nnpi/
+
 INTEL P-Unit IPC DRIVER
 M:	Zha Qipeng <qipeng.zha@intel.com>
 L:	platform-driver-x86@vger.kernel.org
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index ce136d6..4b71838 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -472,4 +472,5 @@ source "drivers/misc/ocxl/Kconfig"
 source "drivers/misc/cardreader/Kconfig"
 source "drivers/misc/habanalabs/Kconfig"
 source "drivers/misc/uacce/Kconfig"
+source "drivers/misc/intel-nnpi/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index c7bd01a..f8fd55d 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -57,3 +57,4 @@ obj-$(CONFIG_PVPANIC)   	+= pvpanic.o
 obj-$(CONFIG_HABANA_AI)		+= habanalabs/
 obj-$(CONFIG_UACCE)		+= uacce/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
+obj-$(CONFIG_INTEL_NNPI)        += intel-nnpi/
diff --git a/drivers/misc/intel-nnpi/Kconfig b/drivers/misc/intel-nnpi/Kconfig
new file mode 100644
index 0000000..a63dda5
--- /dev/null
+++ b/drivers/misc/intel-nnpi/Kconfig
@@ -0,0 +1,17 @@
+#
+# Copyright (C) 2019-2020 Intel Corporation
+#
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+
+config INTEL_NNPI
+	tristate "Intel(R) NNP-I (AI accelerator for inference) device driver"
+	depends on PCI
+	select DMA_SHARED_BUFFER
+	help
+	  Device driver for Intel NNP-I PCIe accelerator card for AI inference.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here. The module
+	  will be called intel_nnpidrv.
diff --git a/drivers/misc/intel-nnpi/Makefile b/drivers/misc/intel-nnpi/Makefile
new file mode 100644
index 0000000..6851010
--- /dev/null
+++ b/drivers/misc/intel-nnpi/Makefile
@@ -0,0 +1,11 @@
+#
+# Copyright (C) 2019-2020 Intel Corporation
+#
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+
+obj-m	:= intel_nnpidrv.o
+
+intel_nnpidrv-y := nnpdrv_main.o pcie.o device.o
+
+ccflags-y += -I$(srctree)/$(src)/ipc_include
diff --git a/drivers/misc/intel-nnpi/device.c b/drivers/misc/intel-nnpi/device.c
new file mode 100644
index 0000000..9e403bc
--- /dev/null
+++ b/drivers/misc/intel-nnpi/device.c
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#define pr_fmt(fmt)   KBUILD_MODNAME ": %s, " fmt, __func__
+
+#include "device.h"
+#include <linux/device.h>
+#include <linux/idr.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
+#include <linux/printk.h>
+#include <linux/sched/clock.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include "pcie.h"
+
+static struct ida dev_ida;
+
+int nnpdrv_device_init(void)
+{
+	ida_init(&dev_ida);
+	return 0;
+}
+
+void nnpdrv_device_fini(void)
+{
+	ida_destroy(&dev_ida);
+}
+
+/**
+ * nnpdrv_device_process_messages - process response messages from nnpi device
+ *
+ * @nnpdev: The nnp device
+ * @hw_msg: pointer to response message content
+ * @hw_nof_msg: number of 64-bit units available in hw_msg buffer.
+ *
+ * This function is called from the pci layer when response messages are arrived
+ * in the HWQ.
+ * It is called from bottom-half context and is *NOT* re-entrant!
+ * The function may not block !
+ */
+void nnpdrv_device_process_messages(struct nnp_device *nnpdev,
+				    u64               *hw_msg,
+				    unsigned int       hw_nof_msg)
+{
+	/* placeholder - will be filled in later patches */
+}
+
+/**
+ * nnpdrv_device_create - creates a nnp device structure.
+ *
+ * @hw_handle: pointer to the pci ("hw layer") structure for this NNP-I device
+ * @hw_dinfo: pointer to pci device info
+ *
+ * This function is called by the pci layer when a new NNP-I device is probed.
+ * The function creates "logical" structure for the device.
+ *
+ * This interface allows to replace the "pci" layer with an implementation which
+ * simulates a device without any real pci device. The "driver" layer and "pci"
+ * layer (implemented in pcie.c) relies on the interface described in pcie.h only.
+ *
+ * The nnp_hw_device_info structure includes information which exist also in
+ * struct pci_dev but this is for the same reason to allow the "pci" layer to
+ * simulate a non-pci device.
+ *
+ * Return: pointer to allocated and initialize nnp device struct or error value
+ */
+struct nnp_device *nnpdrv_device_create(struct nnp_pci_device        *hw_handle,
+				      const struct nnp_hw_device_info *hw_dinfo)
+{
+	struct nnp_device *nnpdev;
+	int ret;
+
+	nnpdev = kzalloc(sizeof(*nnpdev), GFP_KERNEL);
+	if (!nnpdev)
+		return ERR_PTR(-ENOMEM);
+
+	nnpdev->id = -1;
+	ret = ida_simple_get(&dev_ida, 0, NNP_MAX_DEVS, GFP_KERNEL);
+	if (ret < 0) {
+		pr_err("failed to allocate NNP-I device number\n");
+		goto err_exit;
+	}
+
+	nnpdev->id = ret;
+
+	pr_debug("nnpdev id is : %u\n", nnpdev->id);
+
+	ret = snprintf(nnpdev->name,
+		       sizeof(nnpdev->name),
+		       "nnpdev%u", nnpdev->id);
+	if (ret < 0 || ret >= sizeof(nnpdev->name)) {
+		ret = -EFAULT;
+		goto err_exit;
+	}
+
+	nnpdev->hw_handle = hw_handle;
+	nnpdev->hw_device_info = hw_dinfo;
+
+	kref_init(&nnpdev->ref);
+
+	pr_debug("Created NNP-I device %u\n", nnpdev->id);
+
+	return nnpdev;
+
+err_exit:
+	if (-1 != nnpdev->id)
+		ida_simple_remove(&dev_ida, nnpdev->id);
+	kfree(nnpdev);
+	pr_err("create device failed\n");
+	return ERR_PTR(ret);
+}
+
+/**
+ * nnpdrv_card_doorbell_value_changed - card doorbell changed notification
+ *
+ * @nnpdev: The nnp device
+ * @doorbell_val: The new value of the doorbell register
+ *
+ * This function is called from the pci layer when the device's doorbell
+ * register is changed.
+ * The function is called from bottom-half.
+ */
+void nnpdrv_card_doorbell_value_changed(struct nnp_device *nnpdev,
+					u32                doorbell_val)
+{
+	pr_debug("Got card doorbell value 0x%x\n", doorbell_val);
+}
+
+/**
+ * nnpdrv_device_destroy - destroy nnp device object and wait until its removed
+ *
+ * @nnpdev: The nnp device to be destroyed.
+ * @prepare_only: flag to stop use device resources, without destroy or wait
+ *
+ * This function is called by the pci layer when a nnp pci device is removed.
+ * It will be called twise, first with @prepare_only set to true
+ * before the device pci memory is unmapped and later with @prepare_only set
+ * to false after the device resources are released.
+ *
+ * When prepare_only is false, the function will inform all device clients
+ * that the device is being removed, will decrement its ref-count and wait
+ * until refcount reaches zero and device structure has been freed.
+ */
+void nnpdrv_device_destroy(struct nnp_device *nnpdev, bool prepare_only)
+{
+	struct completion completion;
+	u32 id = nnpdev->id;
+
+	if (prepare_only) {
+		pr_debug("Prepare device Destroy NNP-I device %u\n", nnpdev->id);
+
+		return;
+	}
+
+	pr_debug("Destroying NNP-I device %u\n", nnpdev->id);
+
+	/*
+	 * Decrement nnp_device refcount and wait until
+	 * all clients get disconnected, refcount reaches 0 and nnp_device
+	 * is released and freed
+	 */
+	init_completion(&completion);
+	nnpdev->release_completion = &completion;
+	nnpdrv_device_put(nnpdev);
+	pr_info("Waiting device %u clients to exit\n", id);
+	wait_for_completion(&completion);
+	pr_info("Device %u destroy done\n", id);
+}
+
+static void nnpdrv_free_device(struct work_struct *work)
+{
+	struct nnp_device *nnpdev = container_of(work,
+						 struct nnp_device,
+						 free_work);
+
+	struct completion *completion = nnpdev->release_completion;
+
+	pr_debug("Freeing NNP-I device %u\n", nnpdev->id);
+
+	ida_simple_remove(&dev_ida, nnpdev->id);
+
+	kfree(nnpdev);
+
+	if (WARN_ON(!completion))
+		return;
+
+	complete(completion);
+}
+
+static void release_nnp_device(struct kref *kref)
+{
+	struct nnp_device *nnpdev = container_of(kref,
+						 struct nnp_device,
+						 ref);
+
+	/*
+	 * schedule work item to actually free the device since
+	 * the device refcount can reach zero from within nnpdev->wq work item.
+	 * This will cause dead-lock since we try to flush and destroy that
+	 * workqueue when freeing the device.
+	 */
+	INIT_WORK(&nnpdev->free_work, nnpdrv_free_device);
+	queue_work(system_wq, &nnpdev->free_work);
+}
+
+int nnpdrv_device_get(struct nnp_device *nnpdev)
+{
+	return kref_get_unless_zero(&nnpdev->ref);
+}
+
+void nnpdrv_device_put(struct nnp_device *nnpdev)
+{
+	kref_put(&nnpdev->ref, release_nnp_device);
+}
diff --git a/drivers/misc/intel-nnpi/device.h b/drivers/misc/intel-nnpi/device.h
new file mode 100644
index 0000000..487af2f
--- /dev/null
+++ b/drivers/misc/intel-nnpi/device.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+#ifndef _NNPDRV_DEVICE_H
+#define _NNPDRV_DEVICE_H
+
+#include <linux/completion.h>
+#include <linux/idr.h>
+#include <linux/kernel.h>
+#include <linux/kref.h>
+#include <linux/workqueue.h>
+#include "pcie.h"
+
+#define NNP_MAX_DEVS		256
+#define DEVICE_NAME_LEN         32
+
+struct nnp_device {
+	struct kref    ref;
+	struct nnp_pci_device             *hw_handle;
+	const struct nnp_hw_device_info   *hw_device_info;
+	struct completion *release_completion;
+	struct work_struct free_work;
+
+	int            id;
+	char           name[DEVICE_NAME_LEN];
+};
+
+int nnpdrv_device_init(void);
+void nnpdrv_device_fini(void);
+
+int nnpdrv_device_get(struct nnp_device *nnpdev);
+void nnpdrv_device_put(struct nnp_device *nnpdev);
+
+#endif
diff --git a/drivers/misc/intel-nnpi/ipc_include/nnp_boot_defs.h b/drivers/misc/intel-nnpi/ipc_include/nnp_boot_defs.h
new file mode 100644
index 0000000..ff52c18
--- /dev/null
+++ b/drivers/misc/intel-nnpi/ipc_include/nnp_boot_defs.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#ifndef _NNP_DOORBELL_H
+#define _NNP_DOORBELL_H
+
+/*
+ * Value fields of card->host doorbell status register HOST_PCI_DOORBELL_VALUE
+ */
+#define NNP_CARD_BOOT_STATE_MASK            0xff
+#define NNP_CARD_BOOT_STATE_SHIFT           0
+#define NNP_CARD_BIOS_UPDATE_COUNTER_MASK   0xf00
+#define NNP_CARD_BIOS_UPDATE_COUNTER_SHIFT  8
+#define NNP_CARD_ERROR_MASK                 0xf000
+#define NNP_CARD_ERROR_SHIFT                12
+#define NNP_CARD_KEEP_ALIVE_MASK            0x00f00000
+#define NNP_CARD_KEEP_ALIVE_SHIFT           20
+
+/* Possible values for card boot state */
+/* bios has not yet initialized */
+#define NNP_CARD_BOOT_STATE_NOT_READY       0
+/* bios initilaized and waiting for os boot image over pci */
+#define NNP_CARD_BOOT_STATE_BIOS_READY      1
+/* recovery bios initilaized and waiting for capsule update over pci */
+#define NNP_CARD_BOOT_STATE_RECOVERY_BIOS_READY 2
+/* bios copied boot image successfully, os boot has started */
+#define NNP_CARD_BOOT_STATE_BOOT_STARTED    3
+/* card has booted and card driver has loaded */
+#define NNP_CARD_BOOT_STATE_DRV_READY       4
+/* card driver finished initialization and user space daemon has started */
+#define NNP_CARD_BOOT_STATE_CARD_READY      8
+/* bios copied data into the system info structure */
+#define NNP_CARD_BOOT_STATE_BIOS_SYSINFO_READY 10
+/* bios capsule update has started flashing the bios image */
+#define NNP_CARD_BOOT_STATE_BIOS_FLASH_STARTED 0x20
+
+/* Possible card error values */
+#define NNP_CARD_ERROR_HOST_ERROR           1
+#define NNP_CARD_ERROR_BOOT_PARAMS          2
+#define NNP_CARD_ERROR_IMAGE_COPY           3
+#define NNP_CARD_ERROR_CORRUPTED_IMAGE      4
+#define NNP_CARD_ERROR_NOT_CAPSULE          8
+#define NNP_CARD_ERROR_CAPSULE_FAILED       9
+/*
+ * Value fields of host->card doorbell status register PCI_HOST_DOORBELL_VALUE
+ */
+#define NNP_HOST_BOOT_STATE_MASK            0xf
+#define NNP_HOST_BOOT_STATE_SHIFT           0
+#define NNP_HOST_ERROR_MASK                 0xf0
+#define NNP_HOST_ERROR_SHIFT                4
+#define NNP_HOST_DRV_STATE_MASK             0xf00
+#define NNP_HOST_DRV_STATE_SHIFT            8
+#define NNP_HOST_DRV_REQUEST_SELF_RESET_MASK  0x10000
+#define NNP_HOST_DRV_REQUEST_SELF_RESET_SHIFT 16
+#define NNP_HOST_KEEP_ALIVE_MASK            0x00f00000
+#define NNP_HOST_KEEP_ALIVE_SHIFT           20
+#define NNP_HOSY_P2P_POKE_MASK              0xff000000
+#define NNP_HOSY_P2P_POKE_SHIFT             24
+
+/* Possible values for host boot state */
+/* boot/bios image is not loaded yet to memory */
+#define NNP_HOST_BOOT_STATE_IMAGE_NOT_READY         0
+/* host driver is up and ready */
+#define NNP_HOST_BOOT_STATE_DRV_READY               (0x1 | 0x8)
+/* debug os image is loaded and ready in memory */
+#define NNP_HOST_BOOT_STATE_DEBUG_OS_IMAGE_READY    (0x2 | 0x8)
+/* bios image is loaded and ready in memory */
+#define NNP_HOST_BOOT_STATE_BIOS_IMAGE_READY        (0x3 | 0x8)
+/* debug bios image is loaded and ready in memory */
+#define NNP_HOST_BOOT_STATE_DEBUG_BIOS_IMAGE_READY  (0x4 | 0x8)
+
+/* Possible values for host error */
+#define NNP_HOST_ERROR_CANNOT_LOAD_IMAGE     1
+
+/* Possible values for host driver state */
+/* driver did not detected the device yet */
+#define NNP_HOST_DRV_STATE_NOT_READY         0
+/* driver initialized and ready */
+#define NNP_HOST_DRV_STATE_READY             1
+/* host/card protocol version mismatch */
+#define NNP_HOST_DRV_STATE_VERSION_ERROR     2
+
+#endif
diff --git a/drivers/misc/intel-nnpi/ipc_include/nnp_elbi.h b/drivers/misc/intel-nnpi/ipc_include/nnp_elbi.h
new file mode 100644
index 0000000..aaf4524
--- /dev/null
+++ b/drivers/misc/intel-nnpi/ipc_include/nnp_elbi.h
@@ -0,0 +1,151 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+#ifndef _NNP_ELBI_H
+#define _NNP_ELBI_H
+
+#include <linux/bitops.h>
+
+/*
+ * Macros for accessing bit fields according to mask and shift
+ */
+#define ELBI_BF_GET(regval, mask, shift)       (((regval) & (mask)) >> (shift))
+#define ELBI_BF_VAL(val, mask, shift)          (((val) << (shift)) & (mask))
+#define ELBI_BF_SET(regval, val, mask, shift)   \
+	((regval) = (((regval) & ~(mask)) |     \
+		     ELBI_BF_VAL((val), (mask), (shift))))
+
+#define ELBI_LINE_BDF                         (ELBI_BASE + 0x4)
+
+/*
+ * COMMAND FIFO registers
+ */
+#define ELBI_COMMAND_WRITE_WO_MSI_LOW         (ELBI_BASE + 0x50)
+#define ELBI_COMMAND_WRITE_WO_MSI_HIGH        (ELBI_BASE + 0x54)
+#define ELBI_COMMAND_WRITE_W_MSI_LOW          (ELBI_BASE + 0x58)
+#define ELBI_COMMAND_WRITE_W_MSI_HIGH         (ELBI_BASE + 0x5C)
+
+#define ELBI_COMMAND_FIFO_0_LOW		 (ELBI_BASE + 0x80)
+#define ELBI_COMMAND_FIFO_LOW(i)         (ELBI_COMMAND_FIFO_0_LOW + (i) * 8)
+#define ELBI_COMMAND_FIFO_HIGH(i)        (ELBI_COMMAND_FIFO_0_LOW + (i) * 8 + 4)
+#define ELBI_COMMAND_FIFO_DEPTH          16
+
+#define ELBI_COMMAND_IOSF_CONTROL                         (ELBI_BASE + 0x44)
+#define ELBI_COMMAND_IOSF_CONTROL_READ_POINTER_MASK       GENMASK(3, 0)
+#define ELBI_COMMAND_IOSF_CONTROL_READ_POINTER_SHIFT      0
+#define ELBI_COMMAND_IOSF_CONTROL_WRITE_POINTER_MASK      GENMASK(12, 8)
+#define ELBI_COMMAND_IOSF_CONTROL_WRITE_POINTER_SHIFT     8
+#define ELBI_COMMAND_IOSF_CONTROL_ALMOST_FULL_TH_MASK     GENMASK(19, 16)
+#define ELBI_COMMAND_IOSF_CONTROL_ALMOST_FULL_TH_SHIFT    16
+#define ELBI_COMMAND_IOSF_CONTROL_FLUSH_MASK              BIT(24)
+
+#define ELBI_COMMAND_PCI_CONTROL                          (ELBI_BASE + 0x48)
+#define ELBI_COMMAND_PCI_CONTROL_ALMOST_EMPTY_TH_MASK     GENMASK(3, 0)
+#define ELBI_COMMAND_PCI_CONTROL_ALMOST_EMPTY_TH_SHIFT    0
+#define ELBI_COMMAND_PCI_CONTROL_FLUSH_MASK               BIT(8)
+
+/*
+ * RESPONSE FIFO registers
+ */
+#define ELBI_RESPONSE_WRITE_WO_MSI_LOW        (ELBI_BASE + 0x68)
+#define ELBI_RESPONSE_WRITE_WO_MSI_HIGH       (ELBI_BASE + 0x6C)
+#define ELBI_RESPONSE_WRITE_W_MSI_LOW         (ELBI_BASE + 0x70)
+#define ELBI_RESPONSE_WRITE_W_MSI_HIGH        (ELBI_BASE + 0x74)
+
+#define ELBI_RESPONSE_FIFO_0_LOW        (ELBI_BASE + 0x100)
+#define ELBI_RESPONSE_FIFO_LOW(i)       (ELBI_RESPONSE_FIFO_0_LOW + (i) * 8)
+#define ELBI_RESPONSE_FIFO_HIGH(i)      (ELBI_RESPONSE_FIFO_0_LOW + (i) * 8 + 4)
+#define ELBI_RESPONSE_FIFO_DEPTH        16
+
+#define ELBI_RESPONSE_PCI_CONTROL                       (ELBI_BASE + 0x60)
+#define ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_MASK     GENMASK(3, 0)
+#define ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_SHIFT    0
+#define ELBI_RESPONSE_PCI_CONTROL_WRITE_POINTER_MASK    GENMASK(12, 8)
+#define ELBI_RESPONSE_PCI_CONTROL_WRITE_POINTER_SHIFT   8
+#define ELBI_RESPONSE_PCI_CONTROL_ALMOST_FULL_TH_MASK   GENMASK(19, 16)
+#define ELBI_RESPONSE_PCI_CONTROL_ALMOST_FULL_TH_SHIFT  16
+#define ELBI_RESPONSE_PCI_CONTROL_FLUSH_MASK            BIT(24)
+
+#define ELBI_RESPONSE_IOSF_CONTROL                       (ELBI_BASE + 0x64)
+#define ELBI_RESPONSE_IOSF_CONTROL_ALMOST_EMPTY_TH_MASK  GENAMSK(3, 0)
+#define ELBI_RESPONSE_IOSF_CONTROL_ALMOST_EMPTY_TH_SHIFT 0
+#define ELBI_RESPONSE_IOSF_CONTROL_FLUSH_MASK            BIT(8)
+
+/*
+ * Host side interrupt status & mask register
+ */
+#define ELBI_PCI_STATUS                       (ELBI_BASE + 0x8)
+#define ELBI_PCI_MSI_MASK                     (ELBI_BASE + 0xC)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_EMPTY_MASK               BIT(0)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_ALMOST_EMPTY_MASK        BIT(1)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_READ_UPDATE_MASK         BIT(2)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_FLUSH_MASK               BIT(3)
+#define ELBI_PCI_STATUS_COMMAND_FIFO_WRITE_ERROR_MASK         BIT(4)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_FULL_MASK               BIT(5)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_ALMOST_FULL_MASK        BIT(6)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_NEW_RESPONSE_MASK       BIT(7)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_FLUSH_MASK              BIT(8)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_READ_ERROR_MASK         BIT(9)
+#define ELBI_PCI_STATUS_RESPONSE_FIFO_READ_POINTER_ERROR_MASK BIT(10)
+#define ELBI_PCI_STATUS_DOORBELL_MASK                         BIT(11)
+#define ELBI_PCI_STATUS_DOORBELL_READ_MASK                    BIT(12)
+#define ELBI_PCI_STATUS_FLR_REQUEST_MASK                      BIT(13)
+#define ELBI_PCI_STATUS_LOCAL_D3_MASK                         BIT(14)
+#define ELBI_PCI_STATUS_LOCAL_FLR_MASK                        BIT(15)
+
+#define ELBI_IOSF_STATUS                                   (ELBI_BASE + 0x10)
+#define ELBI_IOSF_MSI_MASK                                 (ELBI_BASE + 0x14)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_FULL_MASK              BIT(0)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_ALMOST_FULL_MASK       BIT(1)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_NEW_COMMAND_MASK       BIT(2)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_FLUSH_MASK             BIT(3)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_READ_ERROR_MASK        BIT(4)
+#define ELBI_IOSF_STATUS_COMMAND_FIFO_READ_POINTER_ERROR_MASK BIT(5)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_EMPTY_MASK            BIT(6)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_ALMOST_EMPTY_MASK     BIT(7)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_READ_UPDATE_MASK      BIT(8)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_FLUSH_MASK            BIT(9)
+#define ELBI_IOSF_STATUS_RESPONSE_FIFO_WRITE_ERROR_MASK      BIT(10)
+#define ELBI_IOSF_STATUS_DOORBELL_MASK                       BIT(11)
+#define ELBI_IOSF_STATUS_DOORBELL_READ_MASK                  BIT(12)
+#define ELBI_IOSF_STATUS_LINE_D3_MASK                        BIT(13)
+#define ELBI_IOSF_STATUS_D_STATE_CHANGE_MASK                 BIT(14)
+#define ELBI_IOSF_STATUS_LINE_FLR_MASK                       BIT(15)
+#define ELBI_IOSF_STATUS_HOT_RESET_MASK                      BIT(16)
+#define ELBI_IOSF_STATUS_PME_TURN_OFF_MASK                   BIT(17)
+#define ELBI_IOSF_STATUS_PERST_B_MASK                        BIT(18)
+#define ELBI_IOSF_STATUS_PERST_ASSERTION_MASK                BIT(19)
+#define ELBI_IOSF_STATUS_DMA_INT_MASK                        BIT(20)
+#define ELBI_IOSF_STATUS_LINE_BME_MASK                       BIT(21)
+#define ELBI_IOSF_STATUS_BME_CHANGE_MASK                     BIT(22)
+#define ELBI_IOSF_STATUS_D0I3_COMPLETE_MASK                  BIT(23)
+#define ELBI_IOSF_STATUS_RST_LOAD_PHY_RECIPE_MASK            BIT(24)
+#define ELBI_IOSF_STATUS_RST_LOAD_PHY_FW_MSK                 BIT(25)
+#define ELBI_IOSF_STATUS_RST_START_PEP_MASK                  BIT(26)
+
+/* DOORBELL registers */
+#define ELBI_PCI_HOST_DOORBELL_VALUE                        (ELBI_BASE + 0x34)
+#define ELBI_HOST_PCI_DOORBELL_VALUE                        (ELBI_BASE + 0x38)
+
+/* CPU_STATUS registers */
+/* CPU_STATUS_0 - Updated by bios with postcode */
+#define ELBI_CPU_STATUS_0                                   (ELBI_BASE + 0x1b8)
+/* CPU_STATUS_1 - Updated by bios with bios flash progress */
+#define ELBI_CPU_STATUS_1                                   (ELBI_BASE + 0x1bc)
+/* CPU_STATUS_2 - Updated by card driver - bitfields below */
+#define ELBI_CPU_STATUS_2                                   (ELBI_BASE + 0x1c0)
+/* CPU_STATUS_3 - not used */
+#define ELBI_CPU_STATUS_3                                   (ELBI_BASE + 0x1c4)
+
+/* Bitfields updated in ELBI_CPU_STATUS_2 indicating card driver states */
+/*
+ * FLR_MODE_MASK 0 == warm reset
+ *               1 == cold reset
+ *               2 == ignore FLR (will not reset the card)
+ */
+#define ELBI_CPU_STATUS_2_FLR_MODE_MASK                     GENMASK(1, 0)
+#define ELBI_CPU_STATUS_2_FLR_MODE_SHIFT                    0
+
+#endif
diff --git a/drivers/misc/intel-nnpi/ipc_include/nnp_inbound_mem.h b/drivers/misc/intel-nnpi/ipc_include/nnp_inbound_mem.h
new file mode 100644
index 0000000..cdff7af
--- /dev/null
+++ b/drivers/misc/intel-nnpi/ipc_include/nnp_inbound_mem.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#ifndef _NNP_INBOUND_MEM_H
+#define _NNP_INBOUND_MEM_H
+
+#include <linux/types.h>
+
+#define NNP_PAGE_SHIFT 12
+
+/* The crash dump buffer size is PAGE-SIZE*2^NNP_CRASH_DUMP_SIZE_PAGE_ORDER or
+ * 2^(PAGE_SHIFT+NNP_CRASH_DUMP_SIZE_PAGE_ORDER)
+ */
+#define NNP_CRASH_DUMP_SIZE_PAGE_ORDER 2
+
+#define NNP_INBOUND_MEM_MAGIC  0x4d687073  /* value of 'sphM' */
+#define NNP_CRASH_DUMP_SIZE   \
+	(1lu << (NNP_PAGE_SHIFT + NNP_CRASH_DUMP_SIZE_PAGE_ORDER))
+#define NNP_CRASH_DUMP_SIZE_PAGES    (NNP_CRASH_DUMP_SIZE >> NNP_PAGE_SHIFT)
+#pragma pack(push, 1)
+
+union nnp_inbound_mem {
+	struct {
+		__le32  magic;
+		__le32  crash_dump_size;
+		__u8	crash_dump[];
+	};
+	__u8 row[NNP_CRASH_DUMP_SIZE];
+};
+
+#pragma pack(pop)
+
+#endif
diff --git a/drivers/misc/intel-nnpi/nnpdrv_main.c b/drivers/misc/intel-nnpi/nnpdrv_main.c
new file mode 100644
index 0000000..75da915
--- /dev/null
+++ b/drivers/misc/intel-nnpi/nnpdrv_main.c
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#define pr_fmt(fmt)   KBUILD_MODNAME ": %s, " fmt, __func__
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/stringify.h>
+#include "device.h"
+#include "pcie.h"
+
+static int nnpdrv_init_module(void)
+{
+	int ret = 0;
+
+	pr_debug("init module\n");
+
+	ret = nnpdrv_device_init();
+	if (ret)
+		return ret;
+
+	ret = nnpdrv_pci_init();
+	if (ret) {
+		pr_err("failed to init pcie\n");
+		ret = -ENODEV;
+		goto err_return;
+	}
+
+	pr_info("NNP-I host driver is up\n");
+
+	return 0;
+
+err_return:
+	return ret;
+}
+
+static void nnpdrv_cleanup(void)
+{
+	pr_debug("Cleaning Up the Module\n");
+
+	nnpdrv_hw_cleanup();
+
+	nnpdrv_device_fini();
+}
+
+module_init(nnpdrv_init_module);
+module_exit(nnpdrv_cleanup);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Intel(R) NNPI Host Driver");
+MODULE_AUTHOR("Intel Corporation");
diff --git a/drivers/misc/intel-nnpi/pcie.c b/drivers/misc/intel-nnpi/pcie.c
new file mode 100644
index 0000000..9f0e25b
--- /dev/null
+++ b/drivers/misc/intel-nnpi/pcie.c
@@ -0,0 +1,793 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+
+#define pr_fmt(fmt)   KBUILD_MODNAME ": %s, " fmt, __func__
+
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/dev_printk.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/printk.h>
+#include <linux/timekeeping.h>
+#include <linux/wait.h>
+#include "nnp_boot_defs.h"
+#include "nnp_inbound_mem.h"
+#include "pcie.h"
+
+/*
+ * SpringHill PCI card identity settings
+ */
+#define NNP_PCI_DEVICE_ID		0x45c6
+#define NNP_PCI_VENDOR_ID		PCI_VENDOR_ID_INTEL
+#define NNP_PCI_DEVFN                   0
+#define NNP_PCI_MMIO_BAR                0
+#define NNP_PCI_INBOUND_MEM_BAR         2
+
+#ifdef CONFIG_64BIT
+#define USE_64BIT_MMIO
+#endif
+
+/*
+ * These are shorcut names to register bitfield masks
+ * defined in ipc_include/nnp_elbi.h
+ */
+#define CMDQ_READ_PTR_MASK          ELBI_COMMAND_IOSF_CONTROL_READ_POINTER_MASK
+#define CMDQ_WRITE_PTR_MASK         ELBI_COMMAND_IOSF_CONTROL_WRITE_POINTER_MASK
+#define RESPQ_READ_PTR_MASK         ELBI_RESPONSE_PCI_CONTROL_READ_POINTER_MASK
+#define RESPQ_WRITE_PTR_MASK        ELBI_RESPONSE_PCI_CONTROL_WRITE_POINTER_MASK
+
+static const char nnp_driver_name[] = "nnp_pcie";
+
+/* interrupt mask bits we enable and handle at interrupt level */
+static u32 card_status_int_mask =
+		   ELBI_PCI_STATUS_COMMAND_FIFO_READ_UPDATE_MASK;
+
+/* interrupt mask bits we enable and handle at threaded interrupt level */
+static u32 card_status_threaded_mask =
+		   ELBI_PCI_STATUS_RESPONSE_FIFO_NEW_RESPONSE_MASK |
+		   ELBI_PCI_STATUS_DOORBELL_MASK;
+
+static int nnp_init_pci_device(struct nnp_pci_device *nnp_pci);
+static void nnp_fini_pci_device(struct nnp_pci_device *nnp_pci);
+
+static void free_nnp_pci(struct kref *kref)
+{
+	struct nnp_pci_device *nnp_pci = container_of(kref,
+						      struct nnp_pci_device,
+						      ref);
+
+	pci_set_drvdata(nnp_pci->pdev, NULL);
+	pci_dev_put(nnp_pci->pdev);
+	kfree(nnp_pci);
+}
+
+static int nnp_pci_put(struct nnp_pci_device *nnp_pci)
+{
+	return kref_put(&nnp_pci->ref, free_nnp_pci);
+}
+
+static inline void nnp_mmio_write(struct nnp_pci_device *nnp_pci,
+				  u32                    off,
+				  u32                    val)
+{
+	iowrite32(val, nnp_pci->mmio.va + off);
+}
+
+static inline u32 nnp_mmio_read(struct nnp_pci_device *nnp_pci,
+				u32               off)
+{
+	return ioread32(nnp_pci->mmio.va + off);
+}
+
+static inline void nnp_mmio_write_8b(struct nnp_pci_device *nnp_pci,
+				     u32                    off,
+				     u64                    val)
+{
+#ifdef USE_64BIT_MMIO
+	writeq(val, nnp_pci->mmio.va + off);
+#else
+	nnp_mmio_write(nnp_pci,
+		       off,
+		       lower_32_bits(val));
+	nnp_mmio_write(nnp_pci,
+		       off,
+		       upper_32_bits(val));
+#endif
+}
+
+static inline u64 nnp_mmio_read_8b(struct nnp_pci_device *nnp_pci,
+				   u32                    off)
+{
+#ifdef USE_64BIT_MMIO
+	u64 ret;
+
+	ret = readq(nnp_pci->mmio.va + off);
+
+	return ret;
+#else
+	u32 low, high;
+	u64 ret;
+
+	low = nnp_mmio_read(nnp_pci,
+			    ELBI_RESPONSE_FIFO_LOW(off));
+	ret = nnp_mmio_read(nnp_pci,
+			    ELBI_RESPONSE_FIFO_HIGH(off));
+	ret = (ret << 32) | low;
+	return ret;
+#endif
+}
+
+static void nnp_process_commands(struct nnp_pci_device *nnp_pci)
+{
+	u32 response_pci_control;
+	u32 read_pointer;
+	u32 write_pointer;
+	u32 avail_slots;
+	int i;
+
+	response_pci_control = nnp_mmio_read(nnp_pci,
+					     ELBI_RESPONSE_PCI_CONTROL);
+	read_pointer = FIELD_GET(RESPQ_READ_PTR_MASK, response_pci_control);
+	write_pointer = FIELD_GET(RESPQ_WRITE_PTR_MASK, response_pci_control);
+	if (read_pointer > write_pointer) {
+		dev_err(nnp_pci->dev, "Mismatched read and write pointers\n");
+		return;
+	}
+
+	/* Commands to read */
+	avail_slots = write_pointer - read_pointer;
+
+	if (!avail_slots)
+		return;
+
+	for (i = 0; i < avail_slots; i++) {
+		read_pointer = (read_pointer + 1) % ELBI_RESPONSE_FIFO_DEPTH;
+
+		nnp_pci->response_buf[i] =
+			nnp_mmio_read_8b(nnp_pci,
+					 ELBI_RESPONSE_FIFO_LOW(read_pointer));
+	}
+
+	/*
+	 * HW restriction - we cannot update the read pointer with the same
+	 * value it currently have. This will be the case if we need to advance
+	 * it by FIFO_DEPTH locations. In this case we will update it in two
+	 * steps, first advance by 1, then to the proper value.
+	 */
+	if (avail_slots == ELBI_COMMAND_FIFO_DEPTH) {
+		u32 next_read_pointer =
+			(read_pointer + 1) % ELBI_RESPONSE_FIFO_DEPTH;
+
+		response_pci_control &= ~(RESPQ_READ_PTR_MASK);
+		response_pci_control |= FIELD_PREP(RESPQ_READ_PTR_MASK,
+						   next_read_pointer);
+		nnp_mmio_write(nnp_pci,
+			       ELBI_RESPONSE_PCI_CONTROL,
+			       response_pci_control);
+	}
+
+	response_pci_control &= ~(RESPQ_READ_PTR_MASK);
+	response_pci_control |= FIELD_PREP(RESPQ_READ_PTR_MASK, read_pointer);
+	nnp_mmio_write(nnp_pci,
+		       ELBI_RESPONSE_PCI_CONTROL,
+		       response_pci_control);
+
+	nnpdrv_device_process_messages(nnp_pci->nnpdev,
+				       nnp_pci->response_buf,
+				       avail_slots);
+}
+
+static irqreturn_t interrupt_handler(int irq, void *data)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)data;
+	irqreturn_t ret;
+	unsigned long flags;
+	bool should_wake = false;
+
+	spin_lock_irqsave(&nnp_pci->irq_lock, flags);
+
+	/* clear interrupts mask */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       UINT_MAX);
+
+	nnp_pci->card_status = nnp_mmio_read(nnp_pci, ELBI_PCI_STATUS);
+
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_STATUS,
+		       nnp_pci->card_status &
+		       (card_status_int_mask | card_status_threaded_mask));
+
+	if (nnp_pci->card_status &
+	    ELBI_PCI_STATUS_COMMAND_FIFO_READ_UPDATE_MASK) {
+		should_wake = true;
+		nnp_pci->cmd_read_update_count++;
+	}
+
+	if (nnp_pci->card_status &
+	    ELBI_PCI_STATUS_RESPONSE_FIFO_NEW_RESPONSE_MASK) {
+		atomic_inc(&nnp_pci->new_response);
+	}
+
+	if (nnp_pci->card_status &
+	    ELBI_PCI_STATUS_DOORBELL_MASK) {
+		nnp_pci->card_doorbell_val =
+			nnp_mmio_read(nnp_pci, ELBI_HOST_PCI_DOORBELL_VALUE);
+
+		atomic_inc(&nnp_pci->doorbell_changed);
+	}
+
+	if (nnp_pci->card_status & card_status_threaded_mask)
+		ret = IRQ_WAKE_THREAD;
+	else
+		ret = IRQ_HANDLED;
+
+	/* Enable desired interrupts */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       ~(card_status_int_mask | card_status_threaded_mask));
+
+	spin_unlock_irqrestore(&nnp_pci->irq_lock, flags);
+
+	if (should_wake)
+		wake_up_all(&nnp_pci->card_status_wait);
+
+	return ret;
+}
+
+static irqreturn_t threaded_interrupt_handler(int irq, void *data)
+{
+	struct nnp_pci_device *nnp_pci = (struct nnp_pci_device *)data;
+
+	if (atomic_xchg(&nnp_pci->doorbell_changed, 0)) {
+		nnpdrv_card_doorbell_value_changed(nnp_pci->nnpdev,
+						   nnp_pci->card_doorbell_val);
+	}
+
+	if (atomic_xchg(&nnp_pci->new_response, 0))
+		nnp_process_commands(nnp_pci);
+
+	return IRQ_HANDLED;
+}
+
+static int nnp_setup_interrupts(struct nnp_pci_device *nnp_pci,
+				struct pci_dev        *pdev)
+{
+	int rc;
+	int irq;
+
+	rc = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);
+	if (rc < 1) {
+		dev_err(nnp_pci->dev, "Error enabling MSI. rc = %d\n", rc);
+		return rc;
+	}
+
+	irq = pci_irq_vector(pdev, 0);
+
+	rc = request_threaded_irq(irq,
+				  interrupt_handler,
+				  threaded_interrupt_handler,
+				  IRQF_ONESHOT,
+				  "nnpi-msi",
+				  nnp_pci);
+	if (rc) {
+		dev_err(nnp_pci->dev, "Error allocating MSI interrupt\n");
+		goto err_irq_req_fail;
+	}
+
+	dev_dbg(nnp_pci->dev, "nnp_pcie MSI irq setup done\n");
+
+	return 0;
+
+err_irq_req_fail:
+	pci_free_irq_vectors(pdev);
+	return rc;
+}
+
+static void nnp_free_interrupts(struct nnp_pci_device *nnp_pci,
+				struct pci_dev        *pdev)
+{
+	/* clear interrupts mask */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       UINT_MAX);
+	free_irq(pci_irq_vector(pdev, 0), nnp_pci);
+	pci_free_irq_vectors(pdev);
+}
+
+static int nnp_cmdq_write_mesg_nowait(struct nnp_pci_device *nnp_pci,
+				      u64                   *msg,
+				      u32                    size,
+				      u32                   *read_update_count)
+{
+	u32 cmd_iosf_control;
+	u32 read_pointer, write_pointer;
+	unsigned long flags;
+	int i;
+
+	if (!nnp_pci->initted)
+		return -ENODEV;
+
+	if (size < 1)
+		return 0;
+
+	spin_lock(&nnp_pci->cmdq_lock);
+
+	if (nnp_pci->cmdq_free_slots < size) {
+		/* read command fifo pointers and compute free slots in fifo */
+		spin_lock_irqsave(&nnp_pci->irq_lock, flags);
+		cmd_iosf_control = nnp_mmio_read(nnp_pci,
+						 ELBI_COMMAND_IOSF_CONTROL);
+		read_pointer = FIELD_GET(CMDQ_READ_PTR_MASK, cmd_iosf_control);
+		write_pointer =
+			FIELD_GET(CMDQ_WRITE_PTR_MASK, cmd_iosf_control);
+
+		nnp_pci->cmdq_free_slots = ELBI_COMMAND_FIFO_DEPTH -
+					   (write_pointer - read_pointer);
+
+		if (nnp_pci->cmdq_free_slots < size) {
+			*read_update_count = nnp_pci->cmd_read_update_count;
+			spin_unlock_irqrestore(&nnp_pci->irq_lock, flags);
+			spin_unlock(&nnp_pci->cmdq_lock);
+			return -EAGAIN;
+		}
+		spin_unlock_irqrestore(&nnp_pci->irq_lock, flags);
+	}
+
+	/* Write all but the last message without generating msi on card */
+	for (i = 0; i < size - 1; i++) {
+		nnp_mmio_write_8b(nnp_pci,
+				  ELBI_COMMAND_WRITE_WO_MSI_LOW,
+				  msg[i]);
+	}
+
+	/* Write last message with generating interrupt on card */
+	nnp_mmio_write_8b(nnp_pci,
+			  ELBI_COMMAND_WRITE_W_MSI_LOW,
+			  msg[i]);
+
+	nnp_pci->cmdq_free_slots -= size;
+
+	spin_unlock(&nnp_pci->cmdq_lock);
+
+	return 0;
+}
+
+int nnp_cmdq_write_mesg(struct nnp_pci_device *nnp_pci,
+			u64                   *msg,
+			u32                    size,
+			u64                  *timed_wait)
+{
+	int rc;
+	u32 read_update_count = 0;
+	u64 start = 0;
+
+	rc = nnp_cmdq_write_mesg_nowait(nnp_pci, msg, size,
+					&read_update_count);
+	if (rc == -EAGAIN && timed_wait) {
+		start = ktime_get_real_ns();
+	} else if (timed_wait) {
+		*timed_wait = 0;
+		timed_wait = NULL;
+	}
+
+	while (rc == -EAGAIN) {
+		rc = wait_event_interruptible(
+			nnp_pci->card_status_wait,
+			read_update_count != nnp_pci->cmd_read_update_count ||
+			!nnp_pci->initted);
+		if (rc)
+			break;
+
+		rc = nnp_cmdq_write_mesg_nowait(nnp_pci, msg, size,
+						&read_update_count);
+	}
+
+	if (timed_wait)
+		*timed_wait = ktime_get_real_ns() - start;
+
+	if (rc)
+		dev_err(nnp_pci->dev,
+			"failed to write message size %d rc=%d!!\n", size, rc);
+
+	return rc;
+}
+
+int nnp_cmdq_flush(struct nnp_pci_device *nnp_pci)
+{
+	if (!nnp_pci->initted)
+		return -ENODEV;
+
+	nnp_mmio_write(nnp_pci,
+		       ELBI_COMMAND_PCI_CONTROL,
+		       ELBI_COMMAND_PCI_CONTROL_FLUSH_MASK);
+
+	return 0;
+}
+
+u32 nnp_get_card_doorbell_value(struct nnp_pci_device *nnp_pci)
+{
+	u32 doorbell_val;
+
+	/* in case we are called during device reset/remove */
+	if (!nnp_pci->initted)
+		return 0xffffffff;
+
+	doorbell_val = nnp_mmio_read(nnp_pci, ELBI_HOST_PCI_DOORBELL_VALUE);
+	return doorbell_val;
+}
+
+int nnp_set_host_doorbell_value(struct nnp_pci_device *nnp_pci, u32 value)
+{
+	if (!nnp_pci->initted)
+		return -ENODEV;
+
+	/*
+	 * The SELF_RESET bit is set only by the h/w layer,
+	 * do not allow higher layer to set it
+	 */
+	value &= ~(NNP_HOST_DRV_REQUEST_SELF_RESET_MASK);
+
+	nnp_mmio_write(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE, value);
+
+	return 0;
+}
+
+u32 nnp_get_postcode(struct nnp_pci_device *nnp_pci)
+{
+	u32 val;
+
+	/* in case we are called during device reset/remove */
+	if (!nnp_pci->initted)
+		return 0xffffffff;
+
+	/* bios post-code is reported in CPU_STATUS_0 register */
+	val = nnp_mmio_read(nnp_pci, ELBI_CPU_STATUS_0);
+
+	return val;
+}
+
+u32 nnp_get_bios_flash_progress(struct nnp_pci_device *nnp_pci)
+{
+	u32 val;
+
+	/* in case we are called during device reset/remove */
+	if (!nnp_pci->initted)
+		return 0xffffffff;
+
+	/* bios flash progress is reported in CPU_STATUS_1 register */
+	val = nnp_mmio_read(nnp_pci, ELBI_CPU_STATUS_1);
+
+	return val;
+}
+
+int nnp_fw_update_complete(struct nnp_pci_device *nnp_pci, bool start)
+{
+	u32 card_state;
+	u32 host_db_val;
+	bool need;
+
+	if (!nnp_pci->initted)
+		return -ENODEV;
+
+	card_state = nnp_mmio_read(nnp_pci, ELBI_CPU_STATUS_2);
+	need = (FIELD_GET(ELBI_CPU_STATUS_2_FLR_MODE_MASK, card_state) == 1);
+
+	/* return 0 if fw update complete flow is not required */
+	if (!need)
+		return 0;
+
+	/* just return required state if not requested to act */
+	if (!start)
+		return 1;
+
+	/*
+	 * flag the device it may start firmware update completion.
+	 * NOTE: PCIe link may drop during this flow!
+	 */
+	host_db_val = nnp_mmio_read(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE);
+	host_db_val |= NNP_HOST_DRV_REQUEST_SELF_RESET_MASK;
+	nnp_mmio_write(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE, host_db_val);
+
+	/* required and started */
+	return 1;
+}
+
+int nnp_get_membar_addr(struct nnp_pci_device *nnp_pci,
+			u64                   *out_phy_addr,
+			void                 **out_vaddr,
+			size_t                 *out_size)
+{
+	if (out_phy_addr)
+		*out_phy_addr = nnp_pci->mem_bar.pa;
+
+	if (out_vaddr)
+		*out_vaddr = nnp_pci->mem_bar.va;
+
+	if (out_size)
+		*out_size = nnp_pci->mem_bar.len;
+
+	return 0;
+}
+
+dma_addr_t nnp_get_host_doorbell_addr(struct nnp_pci_device *nnp_pci)
+{
+	/* Doorbell is a shared resource. For peer-to-peer we use only MSB */
+	return (nnp_pci->mmio.pa + ELBI_PCI_HOST_DOORBELL_VALUE + 3);
+}
+
+static int nnp_init_pci_device(struct nnp_pci_device *nnp_pci)
+{
+	struct pci_dev *pdev = nnp_pci->pdev;
+	u32 doorbell_val, status;
+	int rc;
+	u32 line_bdf;
+
+	/* enable device */
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		dev_err(nnp_pci->dev,
+			"failed to enable pci device. rc=%d\n", rc);
+		return rc;
+	}
+
+	/* enable bus master capability on device */
+	pci_set_master(pdev);
+
+	rc = pci_request_regions(pdev, nnp_driver_name);
+	if (rc) {
+		dev_err(nnp_pci->dev, "failed to get pci regions.\n");
+		goto disable_device;
+	}
+
+	nnp_pci->mmio.pa = pci_resource_start(pdev, NNP_PCI_MMIO_BAR);
+	nnp_pci->mmio.len = pci_resource_len(pdev, NNP_PCI_MMIO_BAR);
+	nnp_pci->mmio.va = pci_ioremap_bar(pdev, NNP_PCI_MMIO_BAR);
+	if (!nnp_pci->mmio.va) {
+		dev_err(nnp_pci->dev, "Cannot remap MMIO BAR\n");
+		rc = -EIO;
+		goto release_regions;
+	}
+
+	/* Map inbound memory region BAR */
+	nnp_pci->mem_bar.pa = pci_resource_start(pdev, NNP_PCI_INBOUND_MEM_BAR);
+	nnp_pci->mem_bar.len = pci_resource_len(pdev, NNP_PCI_INBOUND_MEM_BAR);
+	nnp_pci->mem_bar.va = pci_ioremap_bar(pdev, NNP_PCI_INBOUND_MEM_BAR);
+	if (!nnp_pci->mem_bar.va) {
+		dev_err(nnp_pci->dev, "Cannot remap INBOUND_MEM BAR\n");
+		rc = -EIO;
+		goto unmap_mmio;
+	}
+
+	/*
+	 * Check that the pci link is in good state:
+	 * mmio read should return valid value.
+	 */
+	line_bdf = nnp_mmio_read(nnp_pci, ELBI_LINE_BDF);
+	if (line_bdf == 0xffffffff) {
+		dev_err(nnp_pci->dev,
+			"PCIe link in bad state line_bdf=0x%x\n", line_bdf);
+		rc = -EIO;
+		goto unmap_mem_bar;
+	}
+
+	dev_info(nnp_pci->dev, "LINE_BDF After init 0x%x\n", line_bdf);
+
+	dev_dbg(nnp_pci->dev, "Mapped mem bar, len=0x%zx pa=0x%lx va=0x%lx\n",
+		nnp_pci->mem_bar.len, (uintptr_t)nnp_pci->mem_bar.pa,
+		(uintptr_t)nnp_pci->mem_bar.va);
+
+	dev_dbg(nnp_pci->dev,
+		"nnp_pcie mmio_start is 0x%llx\n", nnp_pci->mmio.pa);
+	dev_dbg(nnp_pci->dev,
+		"nnp_pcie mmio_len   is 0x%zx\n", nnp_pci->mmio.len);
+
+	rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
+	if (rc) {
+		dev_err(nnp_pci->dev, "Cannot set DMA mask\n");
+		goto unmap_mem_bar;
+	}
+
+	/* clear interrupts mask */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       UINT_MAX);
+
+	rc = nnp_setup_interrupts(nnp_pci, pdev);
+	if (rc) {
+		dev_err(nnp_pci->dev, "nnp_setup_interrupts failed %d\n", rc);
+		goto unmap_mem_bar;
+	}
+
+	/*
+	 * done setting up the new pci device,
+	 * add it to the set of NNP-I devices
+	 */
+	if (!nnp_pci->nnpdev) {
+		struct nnp_device *nnpdev;
+
+		nnpdev = nnpdrv_device_create(nnp_pci, &nnp_pci->device_info);
+		if (IS_ERR(nnpdev)) {
+			dev_err(nnp_pci->dev,
+				"failed to register enumarated NNP-I device");
+			rc = PTR_ERR(nnpdev);
+			goto free_interrupts;
+		}
+		nnp_pci->nnpdev = nnpdev;
+	}
+
+	/* notify bios that host driver is up */
+	nnp_cmdq_flush(nnp_pci);
+	doorbell_val = nnp_mmio_read(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE);
+	doorbell_val = (doorbell_val & ~(NNP_HOST_BOOT_STATE_MASK)) |
+		NNP_HOST_BOOT_STATE_DRV_READY << NNP_HOST_BOOT_STATE_SHIFT;
+	nnp_mmio_write(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE, doorbell_val);
+
+	/* Update upper layer with current value of card doorbell value */
+	doorbell_val = nnp_mmio_read(nnp_pci, ELBI_HOST_PCI_DOORBELL_VALUE);
+	nnpdrv_card_doorbell_value_changed(nnp_pci->nnpdev, doorbell_val);
+	status = nnp_mmio_read(nnp_pci, ELBI_PCI_STATUS);
+	if (status & ELBI_PCI_STATUS_DOORBELL_MASK)
+		nnp_mmio_write(nnp_pci,
+			       ELBI_PCI_STATUS, ELBI_PCI_STATUS_DOORBELL_MASK);
+
+	/* process any exising command in the response queue */
+	nnp_process_commands(nnp_pci);
+
+	/* Enable desired interrupts */
+	nnp_mmio_write(nnp_pci,
+		       ELBI_PCI_MSI_MASK,
+		       ~(card_status_int_mask | card_status_threaded_mask));
+
+	dev_dbg(nnp_pci->dev, "nnp_pcie init_pci done.\n");
+
+	nnp_pci->initted = true;
+	return 0;
+
+free_interrupts:
+	nnp_free_interrupts(nnp_pci, pdev);
+unmap_mem_bar:
+	iounmap(nnp_pci->mem_bar.va);
+unmap_mmio:
+	iounmap(nnp_pci->mmio.va);
+release_regions:
+	pci_release_regions(pdev);
+disable_device:
+	pci_disable_device(pdev);
+
+	return rc;
+}
+
+static void nnp_fini_pci_device(struct nnp_pci_device *nnp_pci)
+{
+	if (!nnp_pci->initted)
+		return;
+
+	nnp_pci->initted = false;
+	wake_up_all(&nnp_pci->card_status_wait);
+	nnp_free_interrupts(nnp_pci, nnp_pci->pdev);
+	iounmap(nnp_pci->mem_bar.va);
+	iounmap(nnp_pci->mmio.va);
+	pci_release_regions(nnp_pci->pdev);
+	pci_disable_device(nnp_pci->pdev);
+}
+
+static int nnp_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct nnp_pci_device *nnp_pci = NULL;
+	int rc = -ENODEV;
+
+	if (PCI_FUNC(pdev->devfn) != NNP_PCI_DEVFN) {
+		dev_err(&pdev->dev,
+			"unsupported pci.devfn=%u (driver only supports pci.devfn=%u)\n",
+			PCI_FUNC(pdev->devfn), NNP_PCI_DEVFN);
+		return -ENODEV;
+	}
+
+	nnp_pci = kzalloc(sizeof(*nnp_pci), GFP_KERNEL);
+	if (!nnp_pci) {
+		rc = -ENOMEM;
+		dev_err(&pdev->dev, "nnp_pci kmalloc failed rc %d\n", rc);
+		goto do_exit;
+	}
+
+	kref_init(&nnp_pci->ref);
+	nnp_pci->pdev = pdev;
+	nnp_pci->dev = &pdev->dev;
+	pci_set_drvdata(pdev, nnp_pci);
+
+	nnp_pci->device_info.hw_device = nnp_pci->dev;
+	nnp_pci->device_info.pci_slot = PCI_SLOT(pdev->devfn);
+	nnp_pci->device_info.pci_bus = pdev->bus->number;
+	nnp_pci->device_info.name = pci_name(pdev);
+
+	init_waitqueue_head(&nnp_pci->card_status_wait);
+	spin_lock_init(&nnp_pci->cmdq_lock);
+	spin_lock_init(&nnp_pci->irq_lock);
+
+	rc = nnp_init_pci_device(nnp_pci);
+	if (rc)
+		goto do_exit;
+
+	/*
+	 * Take refcount to the device which will be released only when
+	 * nnpi_pci struct is freed
+	 */
+	pci_dev_get(nnp_pci->pdev);
+
+	dev_dbg(nnp_pci->dev, "nnp_pcie probe done.\n");
+
+	return 0;
+
+do_exit:
+	dev_err(&pdev->dev, "Probe failed rc %d\n", rc);
+	if (nnp_pci)
+		nnp_fini_pci_device(nnp_pci);
+	kfree(nnp_pci);
+	pci_set_drvdata(pdev, NULL);
+	return rc;
+}
+
+static void nnp_remove(struct pci_dev *pdev)
+{
+	struct nnp_pci_device *nnp_pci = NULL;
+
+	nnp_pci = pci_get_drvdata(pdev);
+	if (!nnp_pci)
+		return;
+
+	nnp_pci->removing = true;
+
+	/* inform card that host driver is down */
+	if (nnp_pci->initted)
+		nnp_mmio_write(nnp_pci, ELBI_PCI_HOST_DOORBELL_VALUE, 0);
+
+	nnpdrv_device_destroy(nnp_pci->nnpdev, true);
+	nnp_fini_pci_device(nnp_pci);
+	nnpdrv_device_destroy(nnp_pci->nnpdev, false);
+
+	nnp_pci_put(nnp_pci);
+}
+
+static const struct pci_device_id nnp_pci_tbl[] = {
+	{PCI_DEVICE(NNP_PCI_VENDOR_ID, NNP_PCI_DEVICE_ID)},
+	/* required last entry */
+	{ 0, }
+};
+
+static struct pci_driver nnp_driver = {
+	.name = nnp_driver_name,
+	.id_table = nnp_pci_tbl,
+	.probe = nnp_probe,
+	.remove = nnp_remove
+};
+
+int nnpdrv_pci_init(void)
+{
+	int ret;
+
+	pr_debug("nnp_pci hw_init\n");
+
+	ret = pci_register_driver(&nnp_driver);
+	if (ret) {
+		pr_err("pci_register_driver failed ret %d\n", ret);
+		goto error;
+	}
+
+	return ret;
+
+error:
+	pr_err("init failed ret %d\n", ret);
+	return ret;
+}
+
+void nnpdrv_hw_cleanup(void)
+{
+	pr_debug("Cleanup");
+	pci_unregister_driver(&nnp_driver);
+}
diff --git a/drivers/misc/intel-nnpi/pcie.h b/drivers/misc/intel-nnpi/pcie.h
new file mode 100644
index 0000000..35bf1199
--- /dev/null
+++ b/drivers/misc/intel-nnpi/pcie.h
@@ -0,0 +1,97 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/********************************************
+ * Copyright (C) 2019-2020 Intel Corporation
+ ********************************************/
+#ifndef _NNPDRV_PCIE_H
+#define _NNPDRV_PCIE_H
+
+#include <linux/atomic.h>
+#include <linux/kref.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#define ELBI_BASE         0  /* MMIO offset of ELBI registers */
+#include "nnp_elbi.h"
+
+struct nnp_device;
+struct device;
+
+#define NNP_MAX_COMMAND_HWQ_DEPTH    16
+#define NNP_MAX_RESPONSE_HWQ_DEPTH   16
+
+struct nnp_hw_device_info {
+	struct device *hw_device;
+	int            pci_bus;
+	int            pci_slot;
+	const char    *name;
+};
+
+struct nnp_memdesc {
+	phys_addr_t   pa;
+	void __iomem *va;
+	size_t        len;
+};
+
+struct nnp_pci_device {
+	struct kref     ref;
+	struct pci_dev *pdev;
+	struct device  *dev;
+	struct nnp_device *nnpdev;
+
+	struct nnp_hw_device_info device_info;
+	struct nnp_memdesc mmio;
+	struct nnp_memdesc mem_bar;
+
+	spinlock_t      irq_lock; /* protects cmdq_free_slots calculation */
+	u64             response_buf[ELBI_RESPONSE_FIFO_DEPTH];
+	atomic_t        new_response;
+	atomic_t        doorbell_changed;
+	spinlock_t      cmdq_lock; /* for cmdq write serialization */
+	wait_queue_head_t card_status_wait;
+	u32             card_doorbell_val;
+
+	u32             cmdq_free_slots;
+
+	u32             card_status;
+	u32             cmd_read_update_count;
+
+	u32             initted;
+
+	bool            removing;
+};
+
+/*
+ * Functions implemented by the nnp "pci" layer,
+ * called by the nnp "device" layer
+ */
+int nnp_cmdq_write_mesg(struct nnp_pci_device *nnp_pci, u64 *msg, u32 size, u64 *timed_wait);
+int nnp_cmdq_flush(struct nnp_pci_device *nnp_pci);
+u32 nnp_get_card_doorbell_value(struct nnp_pci_device *nnp_pci);
+int nnp_set_host_doorbell_value(struct nnp_pci_device *nnp_pci, u32 value);
+u32 nnp_get_postcode(struct nnp_pci_device *nnp_pci);
+u32 nnp_get_bios_flash_progress(struct nnp_pci_device *nnp_pci);
+int nnp_fw_update_complete(struct nnp_pci_device *nnp_pci, bool start);
+int nnp_get_membar_addr(struct nnp_pci_device *nnp_pci,
+			u64   *out_phy_addr,
+			void **out_vaddr,
+			size_t  *out_len);
+dma_addr_t nnp_get_host_doorbell_addr(struct nnp_pci_device *nnp_pci);
+
+/*
+ * Functions implemented by the nnp "device" layer,
+ * called by the nnp "pci" layer
+ */
+struct nnp_device *nnpdrv_device_create(struct nnp_pci_device        *hw_handle,
+				     const struct nnp_hw_device_info *hw_dinfo);
+void nnpdrv_device_destroy(struct nnp_device *nnpdev, bool prepare_only);
+void nnpdrv_card_doorbell_value_changed(struct nnp_device *nnpdev,
+					u32                doorbell_val);
+void nnpdrv_device_process_messages(struct nnp_device *nnpdev,
+				    u64               *hw_msg,
+				    unsigned int       hw_nof_msg);
+
+int nnpdrv_pci_init(void);
+void nnpdrv_hw_cleanup(void);
+
+#endif
-- 
1.8.3.1

