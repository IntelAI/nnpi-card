From 60dc29d7b6cd08e856281816c18b0de50d2dae1f Mon Sep 17 00:00:00 2001
From: Alexey Skidanov <alexey.skidanov@intel.com>
Date: Wed, 31 Oct 2018 21:15:17 +0200
Subject: [PATCH 1/2] stanging: android: ion: Change to support new SPH memory
 allocator

---
 drivers/staging/android/ion/ion-ioctl.c         |   3 +-
 drivers/staging/android/ion/ion.c               |  56 +++++++++---
 drivers/staging/android/ion/ion.h               |  15 ++--
 drivers/staging/android/ion/ion_carveout_heap.c |  73 +++++++++++-----
 drivers/staging/android/ion/ion_chunk_heap.c    | 108 ++++++++++++++++++------
 drivers/staging/android/ion/ion_cma_heap.c      |   3 +-
 drivers/staging/android/ion/ion_system_heap.c   |   6 +-
 drivers/staging/android/uapi/ion.h              |   2 +-
 include/linux/ion_exp.h                         |  15 ++++
 9 files changed, 213 insertions(+), 68 deletions(-)
 create mode 100644 include/linux/ion_exp.h

diff --git a/drivers/staging/android/ion/ion-ioctl.c b/drivers/staging/android/ion/ion-ioctl.c
index 6cfed48..cbcc969 100644
--- a/drivers/staging/android/ion/ion-ioctl.c
+++ b/drivers/staging/android/ion/ion-ioctl.c
@@ -85,7 +85,8 @@ long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 		fd = ion_alloc(data.allocation.len,
 			       data.allocation.heap_id_mask,
-			       data.allocation.flags);
+			       data.allocation.flags,
+			       data.allocation.alignment);
 		if (fd < 0)
 			return fd;
 
diff --git a/drivers/staging/android/ion/ion.c b/drivers/staging/android/ion/ion.c
index f480885..62ea959 100644
--- a/drivers/staging/android/ion/ion.c
+++ b/drivers/staging/android/ion/ion.c
@@ -78,7 +78,8 @@ static void ion_buffer_add(struct ion_device *dev,
 static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
 					    struct ion_device *dev,
 					    unsigned long len,
-					    unsigned long flags)
+					    unsigned long flags,
+					    u32 alignment)
 {
 	struct ion_buffer *buffer;
 	int ret;
@@ -89,15 +90,17 @@ static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
 
 	buffer->heap = heap;
 	buffer->flags = flags;
+	buffer->dev = dev;
+ 	buffer->size = len;
 
-	ret = heap->ops->allocate(heap, buffer, len, flags);
+	ret = heap->ops->allocate(heap, buffer, len, flags, alignment);
 
 	if (ret) {
 		if (!(heap->flags & ION_HEAP_FLAG_DEFER_FREE))
 			goto err2;
 
 		ion_heap_freelist_drain(heap, 0);
-		ret = heap->ops->allocate(heap, buffer, len, flags);
+		ret = heap->ops->allocate(heap, buffer, len, flags, alignment);
 		if (ret)
 			goto err2;
 	}
@@ -108,11 +111,6 @@ static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
 		goto err1;
 	}
 
-	buffer->dev = dev;
-	buffer->size = len;
-
-	buffer->dev = dev;
-	buffer->size = len;
 	INIT_LIST_HEAD(&buffer->attachments);
 	mutex_init(&buffer->lock);
 	mutex_lock(&dev->buffer_lock);
@@ -375,6 +373,13 @@ static int ion_dma_buf_end_cpu_access(struct dma_buf *dmabuf,
 	return 0;
 }
 
+static void *ion_dma_buf_vmap(struct dma_buf *dmabuf)
+{
+	struct ion_buffer *buffer = dmabuf->priv;
+
+	return buffer->vaddr;
+}
+
 static const struct dma_buf_ops dma_buf_ops = {
 	.map_dma_buf = ion_map_dma_buf,
 	.unmap_dma_buf = ion_unmap_dma_buf,
@@ -388,9 +393,11 @@ static const struct dma_buf_ops dma_buf_ops = {
 	.unmap_atomic = ion_dma_buf_kunmap,
 	.map = ion_dma_buf_kmap,
 	.unmap = ion_dma_buf_kunmap,
+	.vmap = ion_dma_buf_vmap,
+
 };
 
-int ion_alloc(size_t len, unsigned int heap_id_mask, unsigned int flags)
+int ion_alloc(size_t len, unsigned int heap_id_mask, unsigned int flags, u32 alignment)
 {
 	struct ion_device *dev = internal_dev;
 	struct ion_buffer *buffer = NULL;
@@ -417,7 +424,7 @@ int ion_alloc(size_t len, unsigned int heap_id_mask, unsigned int flags)
 		/* if the caller didn't specify this heap id */
 		if (!((1 << heap->id) & heap_id_mask))
 			continue;
-		buffer = ion_buffer_create(heap, dev, len, flags);
+		buffer = ion_buffer_create(heap, dev, len, flags, alignment);
 		if (!IS_ERR(buffer))
 			break;
 	}
@@ -470,8 +477,10 @@ int ion_query_heaps(struct ion_heap_query *query)
 	max_cnt = query->cnt;
 
 	plist_for_each_entry(heap, &dev->heaps, node) {
-		strncpy(hdata.name, heap->name, MAX_HEAP_NAME);
-		hdata.name[sizeof(hdata.name) - 1] = '\0';
+		if (heap->name) {
+			strncpy(hdata.name, heap->name, MAX_HEAP_NAME);
+			hdata.name[sizeof(hdata.name) - 1] = '\0';
+		}
 		hdata.type = heap->type;
 		hdata.heap_id = heap->id;
 
@@ -584,6 +593,29 @@ void ion_device_add_heap(struct ion_heap *heap)
 }
 EXPORT_SYMBOL(ion_device_add_heap);
 
+void ion_device_remove_heap(struct ion_heap *heap)
+{
+	struct ion_device *dev = internal_dev;
+	struct dentry *debug_file;
+
+	down_write(&dev->lock);
+	plist_del(&heap->node, &dev->heaps);
+
+	if (heap->shrinker.count_objects && heap->shrinker.scan_objects) {
+		char debug_name[64];
+
+		snprintf(debug_name, 64, "%s_shrink", heap->name);
+		debug_file = debugfs_lookup(debug_name, dev->debug_root);
+
+		debugfs_remove(debug_file);
+	}
+
+	dev->heap_cnt--;
+	heap_id--;
+	up_write(&dev->lock);
+}
+EXPORT_SYMBOL(ion_device_remove_heap);
+
 static int ion_device_create(void)
 {
 	struct ion_device *idev;
diff --git a/drivers/staging/android/ion/ion.h b/drivers/staging/android/ion/ion.h
index f5f9cd6..516ba55 100644
--- a/drivers/staging/android/ion/ion.h
+++ b/drivers/staging/android/ion/ion.h
@@ -27,6 +27,7 @@
 #include <linux/shrinker.h>
 #include <linux/types.h>
 #include <linux/miscdevice.h>
+#include <linux/ion_exp.h>
 
 #include "../uapi/ion.h"
 
@@ -47,10 +48,10 @@ struct ion_platform_heap {
 	enum ion_heap_type type;
 	unsigned int id;
 	const char *name;
-	phys_addr_t base;
-	size_t size;
 	phys_addr_t align;
-	void *priv;
+	int min_alloc_order;
+	struct mem_chunk *chunks;
+	u32 num_of_chunks;
 };
 
 /**
@@ -124,7 +125,8 @@ struct ion_device {
 struct ion_heap_ops {
 	int (*allocate)(struct ion_heap *heap,
 			struct ion_buffer *buffer, unsigned long len,
-			unsigned long flags);
+			unsigned long flags,
+			u32 alignment);
 	void (*free)(struct ion_buffer *buffer);
 	void * (*map_kernel)(struct ion_heap *heap, struct ion_buffer *buffer);
 	void (*unmap_kernel)(struct ion_heap *heap, struct ion_buffer *buffer);
@@ -214,7 +216,7 @@ bool ion_buffer_fault_user_mappings(struct ion_buffer *buffer);
  * @heap:		the heap to add
  */
 void ion_device_add_heap(struct ion_heap *heap);
-
+void ion_device_remove_heap(struct ion_heap *heap);
 /**
  * some helpers for common operations on buffers using the sg_table
  * and vaddr fields
@@ -228,7 +230,8 @@ int ion_heap_pages_zero(struct page *page, size_t size, pgprot_t pgprot);
 
 int ion_alloc(size_t len,
 	      unsigned int heap_id_mask,
-	      unsigned int flags);
+	      unsigned int flags,
+	      u32 alignment);
 
 /**
  * ion_heap_init_shrinker
diff --git a/drivers/staging/android/ion/ion_carveout_heap.c b/drivers/staging/android/ion/ion_carveout_heap.c
index fee7650..782ec3e 100644
--- a/drivers/staging/android/ion/ion_carveout_heap.c
+++ b/drivers/staging/android/ion/ion_carveout_heap.c
@@ -29,15 +29,29 @@
 struct ion_carveout_heap {
 	struct ion_heap heap;
 	struct gen_pool *pool;
-	phys_addr_t base;
 };
 
 static phys_addr_t ion_carveout_allocate(struct ion_heap *heap,
-					 unsigned long size)
+					 unsigned long size,
+					 u32 alignment)
 {
+	unsigned long offset;
+	struct genpool_data_align data;
 	struct ion_carveout_heap *carveout_heap =
 		container_of(heap, struct ion_carveout_heap, heap);
-	unsigned long offset = gen_pool_alloc(carveout_heap->pool, size);
+
+	/*Set alignment */
+	if (!is_power_of_2(alignment))
+		return ION_CARVEOUT_ALLOCATE_FAIL;
+
+	data.align = alignment;
+	offset = gen_pool_alloc_algo(carveout_heap->pool,
+				     size,
+				     gen_pool_first_fit_align,
+				     &data);
+
+	pr_info("%s: Allocated chunk of %lu bytes at 0x%lX (aligned on 0x%X)\n",
+		__func__, size, offset, alignment);
 
 	if (!offset)
 		return ION_CARVEOUT_ALLOCATE_FAIL;
@@ -54,12 +68,16 @@ static void ion_carveout_free(struct ion_heap *heap, phys_addr_t addr,
 	if (addr == ION_CARVEOUT_ALLOCATE_FAIL)
 		return;
 	gen_pool_free(carveout_heap->pool, addr, size);
+
+	pr_info("%s: Released chunk of %lu bytes at %pa\n",
+		__func__, size, &addr);
 }
 
 static int ion_carveout_heap_allocate(struct ion_heap *heap,
 				      struct ion_buffer *buffer,
 				      unsigned long size,
-				      unsigned long flags)
+				      unsigned long flags,
+				      u32 alignment)
 {
 	struct sg_table *table;
 	phys_addr_t paddr;
@@ -72,7 +90,7 @@ static int ion_carveout_heap_allocate(struct ion_heap *heap,
 	if (ret)
 		goto err_free;
 
-	paddr = ion_carveout_allocate(heap, size);
+	paddr = ion_carveout_allocate(heap, size, alignment);
 	if (paddr == ION_CARVEOUT_ALLOCATE_FAIL) {
 		ret = -ENOMEM;
 		goto err_free_table;
@@ -115,33 +133,50 @@ static struct ion_heap_ops carveout_heap_ops = {
 struct ion_heap *ion_carveout_heap_create(struct ion_platform_heap *heap_data)
 {
 	struct ion_carveout_heap *carveout_heap;
-	int ret;
+	int i, ret;
 
 	struct page *page;
 	size_t size;
 
-	page = pfn_to_page(PFN_DOWN(heap_data->base));
-	size = heap_data->size;
-
-	ret = ion_heap_pages_zero(page, size, pgprot_writecombine(PAGE_KERNEL));
-	if (ret)
-		return ERR_PTR(ret);
-
 	carveout_heap = kzalloc(sizeof(*carveout_heap), GFP_KERNEL);
 	if (!carveout_heap)
 		return ERR_PTR(-ENOMEM);
 
-	carveout_heap->pool = gen_pool_create(PAGE_SHIFT, -1);
+	carveout_heap->pool = gen_pool_create(heap_data->min_alloc_order, -1);
 	if (!carveout_heap->pool) {
-		kfree(carveout_heap);
-		return ERR_PTR(-ENOMEM);
+		ret = -ENOMEM;
+		goto error_gen_pool_create;
 	}
-	carveout_heap->base = heap_data->base;
-	gen_pool_add(carveout_heap->pool, carveout_heap->base, heap_data->size,
-		     -1);
+
+	/* go over the chunks */
+	for (i = 0; i < heap_data->num_of_chunks; i++) {
+		/* Zero out the chunk*/
+		page = pfn_to_page(PFN_DOWN(heap_data->chunks[i].base));
+		size = heap_data->chunks[i].size;
+		ret = ion_heap_pages_zero(page, size, pgprot_writecombine(PAGE_KERNEL));
+		if (ret)
+			goto error_gen_pool_add;
+
+		/* Add chunk to the pool */
+		gen_pool_add(carveout_heap->pool,
+			     heap_data->chunks[i].base,
+			     heap_data->chunks[i].size,
+			     -1);
+
+		pr_info("%s: New memory chunk of 0x%zX bytes starting at %pa added to the pool\n",
+			__func__, heap_data->chunks[i].size, &heap_data->chunks[i].base);
+	}
+
 	carveout_heap->heap.ops = &carveout_heap_ops;
+	carveout_heap->heap.name = heap_data->name;
 	carveout_heap->heap.type = ION_HEAP_TYPE_CARVEOUT;
 	carveout_heap->heap.flags = ION_HEAP_FLAG_DEFER_FREE;
 
 	return &carveout_heap->heap;
+
+error_gen_pool_add:
+	gen_pool_destroy(carveout_heap->pool);
+error_gen_pool_create:
+	kfree(carveout_heap);
+	return ERR_PTR(ret);
 }
diff --git a/drivers/staging/android/ion/ion_chunk_heap.c b/drivers/staging/android/ion/ion_chunk_heap.c
index 102c093..1642fc7 100644
--- a/drivers/staging/android/ion/ion_chunk_heap.c
+++ b/drivers/staging/android/ion/ion_chunk_heap.c
@@ -21,12 +21,13 @@
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
+#include <linux/ion_exp.h>
+
 #include "ion.h"
 
 struct ion_chunk_heap {
 	struct ion_heap heap;
 	struct gen_pool *pool;
-	phys_addr_t base;
 	unsigned long chunk_size;
 	unsigned long size;
 	unsigned long allocated;
@@ -35,7 +36,8 @@ struct ion_chunk_heap {
 static int ion_chunk_heap_allocate(struct ion_heap *heap,
 				   struct ion_buffer *buffer,
 				   unsigned long size,
-				   unsigned long flags)
+				   unsigned long flags,
+				   u32 alignment)
 {
 	struct ion_chunk_heap *chunk_heap =
 		container_of(heap, struct ion_chunk_heap, heap);
@@ -44,10 +46,22 @@ static int ion_chunk_heap_allocate(struct ion_heap *heap,
 	int ret, i;
 	unsigned long num_chunks;
 	unsigned long allocated_size;
-
-	allocated_size = ALIGN(size, chunk_heap->chunk_size);
-	num_chunks = allocated_size / chunk_heap->chunk_size;
-
+	unsigned long allocated_chunk;
+	struct genpool_data_align data;
+
+	 /* Set alignment */
+	if (!is_power_of_2(alignment))
+		return -EINVAL;
+
+	data.align = alignment;
+
+	/* Alignment is also minimal allocated chunk */
+	allocated_chunk = (chunk_heap->chunk_size >= alignment)
+			? chunk_heap->chunk_size
+					: alignment;
+	/* Calculate number of allocated chunks */
+	allocated_size = ALIGN(size, allocated_chunk);
+	num_chunks = allocated_size / allocated_chunk;
 	if (allocated_size > chunk_heap->size - chunk_heap->allocated)
 		return -ENOMEM;
 
@@ -62,15 +76,22 @@ static int ion_chunk_heap_allocate(struct ion_heap *heap,
 
 	sg = table->sgl;
 	for (i = 0; i < num_chunks; i++) {
-		unsigned long paddr = gen_pool_alloc(chunk_heap->pool,
-						     chunk_heap->chunk_size);
+		unsigned long paddr = gen_pool_alloc_algo(chunk_heap->pool,
+							  allocated_chunk,
+							  gen_pool_first_fit_align,
+							  &data);
+
 		if (!paddr)
 			goto err;
 		sg_set_page(sg, pfn_to_page(PFN_DOWN(paddr)),
-			    chunk_heap->chunk_size, 0);
+			    allocated_chunk, 0);
 		sg = sg_next(sg);
 	}
 
+	pr_debug("%s: Allocated memory buffer of %lu bytes (aligned on 0x%X)\n",
+		__func__, size, alignment);
+
+	buffer->size = allocated_size; 
 	buffer->sg_table = table;
 	chunk_heap->allocated += allocated_size;
 	return 0;
@@ -107,6 +128,8 @@ static void ion_chunk_heap_free(struct ion_buffer *buffer)
 	chunk_heap->allocated -= allocated_size;
 	sg_free_table(table);
 	kfree(table);
+
+	pr_debug("%s: Released chunk of 0x%zX bytes\n", __func__, buffer->size);
 }
 
 static struct ion_heap_ops chunk_heap_ops = {
@@ -120,43 +143,76 @@ static struct ion_heap_ops chunk_heap_ops = {
 struct ion_heap *ion_chunk_heap_create(struct ion_platform_heap *heap_data)
 {
 	struct ion_chunk_heap *chunk_heap;
-	int ret;
+	int ret, i;
 	struct page *page;
 	size_t size;
 
-	page = pfn_to_page(PFN_DOWN(heap_data->base));
-	size = heap_data->size;
-
-	ret = ion_heap_pages_zero(page, size, pgprot_writecombine(PAGE_KERNEL));
-	if (ret)
-		return ERR_PTR(ret);
-
 	chunk_heap = kzalloc(sizeof(*chunk_heap), GFP_KERNEL);
 	if (!chunk_heap)
 		return ERR_PTR(-ENOMEM);
 
-	chunk_heap->chunk_size = (unsigned long)heap_data->priv;
-	chunk_heap->pool = gen_pool_create(get_order(chunk_heap->chunk_size) +
-					   PAGE_SHIFT, -1);
+	chunk_heap->chunk_size = BIT(heap_data->min_alloc_order);
+	chunk_heap->pool = gen_pool_create(heap_data->min_alloc_order, -1);
 	if (!chunk_heap->pool) {
 		ret = -ENOMEM;
 		goto error_gen_pool_create;
 	}
-	chunk_heap->base = heap_data->base;
-	chunk_heap->size = heap_data->size;
+
+	chunk_heap->size = 0;
 	chunk_heap->allocated = 0;
+	/* go over the chunks */
+	for (i = 0; i < heap_data->num_of_chunks; i++) {
+		/* Zero out the chunk*/
+		page = pfn_to_page(PFN_DOWN(heap_data->chunks[i].base));
+		size = heap_data->chunks[i].size;
+		ret = ion_heap_pages_zero(page, size, pgprot_writecombine(PAGE_KERNEL));
+		if (ret)
+			goto error_gen_pool_add;
+
+		/* Add chunk to the pool */
+		gen_pool_add(chunk_heap->pool,
+			     heap_data->chunks[i].base,
+			     heap_data->chunks[i].size,
+			     -1);
+
+		pr_debug("%s: New memory chunk of 0x%zX bytes starting at %pa added to the pool\n",
+			__func__, heap_data->chunks[i].size, &heap_data->chunks[i].base);
+
+		chunk_heap->size +=  heap_data->chunks[i].size;
+	}
 
-	gen_pool_add(chunk_heap->pool, chunk_heap->base, heap_data->size, -1);
 	chunk_heap->heap.ops = &chunk_heap_ops;
+	chunk_heap->heap.name = heap_data->name;
 	chunk_heap->heap.type = ION_HEAP_TYPE_CHUNK;
-	chunk_heap->heap.flags = ION_HEAP_FLAG_DEFER_FREE;
-	pr_debug("%s: base %pa size %zu\n", __func__,
-		 &chunk_heap->base, heap_data->size);
 
 	return &chunk_heap->heap;
 
+error_gen_pool_add:
+	gen_pool_destroy(chunk_heap->pool);
 error_gen_pool_create:
 	kfree(chunk_heap);
 	return ERR_PTR(ret);
 }
 
+void *ion_chunk_heap_setup(struct mem_chunk *chunks, u32 num_of_chunks)
+{
+	struct ion_heap *heap;
+	struct ion_platform_heap plat_heap = {.type = ION_HEAP_TYPE_CHUNK,
+					      .name = "chunk_heap",
+					      .min_alloc_order = PAGE_SHIFT,
+					      .chunks = chunks,
+					      .num_of_chunks = num_of_chunks};
+
+	heap = ion_chunk_heap_create(&plat_heap);
+	if (heap)
+		ion_device_add_heap(heap);
+
+	return heap;
+}
+EXPORT_SYMBOL(ion_chunk_heap_setup);
+
+void ion_chunk_heap_remove(void *ion_heap)
+{
+	ion_device_remove_heap(ion_heap);
+}
+EXPORT_SYMBOL(ion_chunk_heap_remove);
diff --git a/drivers/staging/android/ion/ion_cma_heap.c b/drivers/staging/android/ion/ion_cma_heap.c
index 86196ff..5d2d151 100644
--- a/drivers/staging/android/ion/ion_cma_heap.c
+++ b/drivers/staging/android/ion/ion_cma_heap.c
@@ -34,7 +34,8 @@ struct ion_cma_heap {
 /* ION CMA heap operations functions */
 static int ion_cma_allocate(struct ion_heap *heap, struct ion_buffer *buffer,
 			    unsigned long len,
-			    unsigned long flags)
+			    unsigned long flags,
+			    u32 alignment)
 {
 	struct ion_cma_heap *cma_heap = to_cma_heap(heap);
 	struct sg_table *table;
diff --git a/drivers/staging/android/ion/ion_system_heap.c b/drivers/staging/android/ion/ion_system_heap.c
index b6ece18..d163475 100644
--- a/drivers/staging/android/ion/ion_system_heap.c
+++ b/drivers/staging/android/ion/ion_system_heap.c
@@ -125,7 +125,8 @@ static struct page *alloc_largest_available(struct ion_system_heap *heap,
 static int ion_system_heap_allocate(struct ion_heap *heap,
 				    struct ion_buffer *buffer,
 				    unsigned long size,
-				    unsigned long flags)
+				    unsigned long flags,
+				    u32 alignment)
 {
 	struct ion_system_heap *sys_heap = container_of(heap,
 							struct ion_system_heap,
@@ -363,7 +364,8 @@ device_initcall(ion_system_heap_create);
 static int ion_system_contig_heap_allocate(struct ion_heap *heap,
 					   struct ion_buffer *buffer,
 					   unsigned long len,
-					   unsigned long flags)
+					   unsigned long flags,
+					   u32 alignment)
 {
 	int order = get_order(len);
 	struct page *page;
diff --git a/drivers/staging/android/uapi/ion.h b/drivers/staging/android/uapi/ion.h
index 9e21451..5a28c16 100644
--- a/drivers/staging/android/uapi/ion.h
+++ b/drivers/staging/android/uapi/ion.h
@@ -80,7 +80,7 @@ struct ion_allocation_data {
 	__u32 heap_id_mask;
 	__u32 flags;
 	__u32 fd;
-	__u32 unused;
+	__u32 alignment;
 };
 
 #define MAX_HEAP_NAME			32
diff --git a/include/linux/ion_exp.h b/include/linux/ion_exp.h
new file mode 100644
index 0000000..6b7664d1
--- /dev/null
+++ b/include/linux/ion_exp.h
@@ -0,0 +1,15 @@
+#ifndef _ION_EXP_H
+#define _ION_EXP_H
+
+
+#define MAX_NUM_OF_CHUNKS 8
+
+struct mem_chunk {
+	phys_addr_t base;
+	size_t size;
+};
+
+extern void *ion_chunk_heap_setup(struct mem_chunk *chunks, u32 num_of_chunks);
+extern void ion_chunk_heap_remove(void *ion_heap);
+
+#endif /* _ION_EXP_H */
-- 
2.7.4

